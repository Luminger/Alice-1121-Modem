#ifdef SNMP_ATMFORUM_MIB
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.iterate.conf,v 5.5 2002/12/16 22:50:18 hardaker Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "atmForum.h"
#include "atmForumHelper.h"
#include "atmMibHelper.h"
#include "autoconfig.h"

#ifdef DO_ATMFAAL1PROFILETABLE
void
atmfAAL1ProfileTable_contextFree(void *context,
                                 netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfAAL1ProfileTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFAAL1PROFILETABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFAAL1PROFILETABLE *) context)->
         pTableBeginning);
}
#endif                          /* DO_ATMFAAL1PROFILETABLE */

#ifdef DO_ATMFAAL2LESPROFILETABLE
void
atmfAAL2LESProfileTable_contextFree(void *context,
                                    netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfAAL2LESProfileTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFAAL2LESPROFILETABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFAAL2LESPROFILETABLE *) context)->
         pTableBeginning);
}
#endif                          /* DO_ATMFAAL2LESPROFILETABLE */

#ifdef DO_ATMFATMSERVICETYPETABLE
void
atmfAtmServiceTypeTable_contextFree(void *context,
                                    netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfAtmServiceTypeTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFATMSERVICETYPETABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFATMSERVICETYPETABLE *) context)->
         pTableBeginning);
}
#endif                          /* DO_ATMFATMSERVICETYPETABLE */

#ifdef DO_ATMFVPCABRTABLE
void
atmfVpcAbrTable_contextFree(void *context,
                            netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfVpcAbrTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFVPCABRTABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFVPCABRTABLE *) context)->pTableBeginning);
}
#endif                          /* DO_ATMFVPCABRTABLE */

#ifdef DO_ATMFAAL2TRUNKINGPROFILETABLE
void
atmfAAL2TrunkingProfileTable_contextFree(void *context,
                                         netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfAAL2TrunkingProfileTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFAAL2TRUNKINGPROFILETABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFAAL2TRUNKINGPROFILETABLE *) context)->
         pTableBeginning);
}
#endif                          /* DO_ATMFAAL2TRUNKINGPROFILETABLE */

#ifdef DO_ATMFATMSERVICECONNINFOTABLE
void
atmfAtmServiceConnInfoTable_contextFree(void *context,
                                        netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfAtmServiceConnInfoTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFATMSERVICECONNINFOTABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFATMSERVICECONNINFOTABLE *) context)->
         pTableBeginning);
}
#endif                          /* DO_ATMFATMSERVICECONNINFOTABLE */

#ifdef DO_ATMFNETPREFIXTABLE
void
atmfNetPrefixTable_contextFree(void *context,
                               netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfNetPrefixTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFNETPREFIXTABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFNETPREFIXTABLE *) context)->pTableBeginning);
}
#endif                          /* DO_ATMFNETPREFIXTABLE */

#ifdef DO_ATMFVCCABRTABLE
void
atmfVccAbrTable_contextFree(void *context,
                            netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfVccAbrTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFVCCABRTABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFVCCABRTABLE *) context)->pTableBeginning);
}
#endif                          /* DO_ATMFVCCABRTABLE */

#ifdef DO_ATMFAAL5PROFILETABLE
void
atmfAAL5ProfileTable_contextFree(void *context,
                                 netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfAAL5ProfileTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFAAL5PROFILETABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFAAL5PROFILETABLE *) context)->
         pTableBeginning);
}
#endif                          /* DO_ATMFAAL5PROFILETABLE */

#ifdef DO_ATMFATMSERVICECONNINFOEXTENSIONTABLE
void
atmfAtmServiceConnInfoExtensionTable_contextFree(void *context,
                                                 netsnmp_iterator_info
                                                 *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfAtmServiceConnInfoExtensionTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFATMSERVICECONNINFOEXTENSIONTABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFATMSERVICECONNINFOEXTENSIONTABLE *) context)->
         pTableBeginning);
}
#endif                          /* DO_ATMFATMSERVICECONNINFOEXTENSIONTABLE */

#ifdef DO_ATMFAAL34PROFILETABLE
void
atmfAAL34ProfileTable_contextFree(void *context,
                                  netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfAAL34ProfileTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFAAL34PROFILETABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFAAL34PROFILETABLE *) context)->
         pTableBeginning);
}
#endif                          /* DO_ATMFAAL34PROFILETABLE */

#ifdef DO_ATMFSRVCREGTABLE
void
atmfSrvcRegTable_contextFree(void *context,
                             netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfSrvcRegTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFSRVCREGTABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFSRVCREGTABLE *) context)->pTableBeginning);
}
#endif                          /* DO_ATMFSRVCREGTABLE */

#ifdef DO_ATMFADDRESSREGISTRATIONADMINTABLE
void
atmfAddressRegistrationAdminTable_contextFree(void *context,
                                              netsnmp_iterator_info
                                              *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfAddressRegistrationAdminTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFADDRESSREGISTRATIONADMINTABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFADDRESSREGISTRATIONADMINTABLE *) context)->
         pTableBeginning);
}
#endif                          /* DO_ATMFADDRESSREGISTRATIONADMINTABLE */

#ifdef DO_ATMFATMSTATSTABLE
void
atmfAtmStatsTable_contextFree(void *context,
                              netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfAtmStatsTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFATMSTATSTABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFATMSTATSTABLE *) context)->pTableBeginning);
}
#endif                          /* DO_ATMFATMSTATSTABLE */

#ifdef DO_ATMFAAL5PROFILEEXTENSIONTABLE
void
atmfAAL5ProfileExtensionTable_contextFree(void *context,
                                          netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfAAL5ProfileExtensionTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFAAL5PROFILEEXTENSIONTABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFAAL5PROFILEEXTENSIONTABLE *) context)->
         pTableBeginning);
}
#endif                          /* DO_ATMFAAL5PROFILEEXTENSIONTABLE */

#ifdef DO_ATMFAAL2COMMONPROFILETABLE
void
atmfAAL2CommonProfileTable_contextFree(void *context,
                                       netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfAAL2CommonProfileTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFAAL2COMMONPROFILETABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFAAL2COMMONPROFILETABLE *) context)->
         pTableBeginning);
}
#endif                          /* DO_ATMFAAL2COMMONPROFILETABLE */

#ifdef DO_ATMFVPCTABLE
void
atmfVpcTable_contextFree(void *context, netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfVpcTable_contextFree: Dealloc at address %p \n",
                     ((ATM_FORUM_MIB_ATMFVPCTABLE *) context)->
                     pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFVPCTABLE *) context)->pTableBeginning);
}
#endif                          /* DO_ATMFVPCTABLE */

#ifdef DO_ATMFATMLAYERTABLE
void
atmfAtmLayerTable_contextFree(void *context,
                              netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfAtmLayerTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFATMLAYERTABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFATMLAYERTABLE *) context)->pTableBeginning);
}
#endif                          /* DO_ATMFATMLAYERTABLE */

#ifdef DO_ATMFADDRESSTABLE
void
atmfAddressTable_contextFree(void *context,
                             netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfAddressTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFADDRESSTABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFADDRESSTABLE *) context)->pTableBeginning);
}
#endif                          /* DO_ATMFADDRESSTABLE */

#ifdef DO_ATMFPORTTABLE
void
atmfPortTable_contextFree(void *context, netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfPortTable_contextFree: Dealloc at address %p \n",
                     ((ATM_FORUM_MIB_ATMFPORTTABLE *) context)->
                     pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFPORTTABLE *) context)->pTableBeginning);
}
#endif                          /* DO_ATMFPORTTABLE */

#ifdef DO_ATMFVCCTABLE
void
atmfVccTable_contextFree(void *context, netsnmp_iterator_info *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfVccTable_contextFree: Dealloc at address %p \n",
                     ((ATM_FORUM_MIB_ATMFVCCTABLE *) context)->
                     pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFVCCTABLE *) context)->pTableBeginning);
}
#endif                          /* DO_ATMFVCCTABLE */

#ifdef DO_ATMFATMSERVICETYPEEXTENSIONTABLE
void
atmfAtmServiceTypeExtensionTable_contextFree(void *context,
                                             netsnmp_iterator_info
                                             *dont_care)
{
    ATMMIBLOG_DEBUG(("atmfAtmServiceTypeExtensionTable_contextFree: Dealloc at address %p \n", ((ATM_FORUM_MIB_ATMFATMSERVICETYPEEXTENSIONTABLE *) context)->pTableBeginning));
    free(((ATM_FORUM_MIB_ATMFATMSERVICETYPEEXTENSIONTABLE *) context)->
         pTableBeginning);
}
#endif                          /* DO_ATMFATMSERVICETYPEEXTENSIONTABLE */


#ifdef DO_ATMFAAL1PROFILETABLE
/** Initialize the atmfAAL1ProfileTable table by defining its contents and how it's structured */
void
initialize_table_atmfAAL1ProfileTable(void)
{
    static oid      atmfAAL1ProfileTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 12, 3 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("atmfAAL1ProfileTable",
                                            atmfAAL1ProfileTable_handler,
                                            atmfAAL1ProfileTable_oid,
                                            OID_LENGTH
                                            (atmfAAL1ProfileTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfAAL1ProfileIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 8;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        atmfAAL1ProfileTable_get_first_data_point;
    iinfo->get_next_data_point = atmfAAL1ProfileTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfAAL1ProfileTable",
                "Registering table atmfAAL1ProfileTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFAAL1PROFILETABLE */
#ifdef DO_ATMFAAL2LESPROFILETABLE
/** Initialize the atmfAAL2LESProfileTable table by defining its contents and how it's structured */
void
initialize_table_atmfAAL2LESProfileTable(void)
{
    static oid      atmfAAL2LESProfileTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 12, 8 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("atmfAAL2LESProfileTable",
                                            atmfAAL2LESProfileTable_handler,
                                            atmfAAL2LESProfileTable_oid,
                                            OID_LENGTH
                                            (atmfAAL2LESProfileTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfAAL2ProfileIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 3;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        atmfAAL2LESProfileTable_get_first_data_point;
    iinfo->get_next_data_point =
        atmfAAL2LESProfileTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfAAL2LESProfileTable",
                "Registering table atmfAAL2LESProfileTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFAAL2LESPROFILETABLE */
#ifdef DO_ATMFATMSERVICETYPETABLE
/** Initialize the atmfAtmServiceTypeTable table by defining its contents and how it's structured */
void
initialize_table_atmfAtmServiceTypeTable(void)
{
    static oid      atmfAtmServiceTypeTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 12, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("atmfAtmServiceTypeTable",
                                            atmfAtmServiceTypeTable_handler,
                                            atmfAtmServiceTypeTable_oid,
                                            OID_LENGTH
                                            (atmfAtmServiceTypeTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfAtmServiceTypeIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 7;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        atmfAtmServiceTypeTable_get_first_data_point;
    iinfo->get_next_data_point =
        atmfAtmServiceTypeTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfAtmServiceTypeTable",
                "Registering table atmfAtmServiceTypeTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFATMSERVICETYPETABLE */
#ifdef DO_ATMFVPCABRTABLE
/** Initialize the atmfVpcAbrTable table by defining its contents and how it's structured */
void
initialize_table_atmfVpcAbrTable(void)
{
    static oid      atmfVpcAbrTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 9, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("atmfVpcAbrTable",
                                                     atmfVpcAbrTable_handler,
                                                     atmfVpcAbrTable_oid,
                                                     OID_LENGTH
                                                     (atmfVpcAbrTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfVpcAbrPortIndex */
                                     ASN_INTEGER,       /* index: atmfVpcAbrVpi */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 10;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = atmfVpcAbrTable_get_first_data_point;
    iinfo->get_next_data_point = atmfVpcAbrTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfVpcAbrTable",
                "Registering table atmfVpcAbrTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFVPCABRTABLE */
#ifdef DO_ATMFAAL2TRUNKINGPROFILETABLE
/** Initialize the atmfAAL2TrunkingProfileTable table by defining its contents and how it's structured */
void
initialize_table_atmfAAL2TrunkingProfileTable(void)
{
    static oid      atmfAAL2TrunkingProfileTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 12, 7 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("atmfAAL2TrunkingProfileTable",
                                            atmfAAL2TrunkingProfileTable_handler,
                                            atmfAAL2TrunkingProfileTable_oid,
                                            OID_LENGTH
                                            (atmfAAL2TrunkingProfileTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfAAL2ProfileIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 2;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        atmfAAL2TrunkingProfileTable_get_first_data_point;
    iinfo->get_next_data_point =
        atmfAAL2TrunkingProfileTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfAAL2TrunkingProfileTable",
                "Registering table atmfAAL2TrunkingProfileTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFAAL2TRUNKINGPROFILETABLE */
#ifdef DO_ATMFATMSERVICECONNINFOTABLE
/** Initialize the atmfAtmServiceConnInfoTable table by defining its contents and how it's structured */
void
initialize_table_atmfAtmServiceConnInfoTable(void)
{
    static oid      atmfAtmServiceConnInfoTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 12, 2 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("atmfAtmServiceConnInfoTable",
                                            atmfAtmServiceConnInfoTable_handler,
                                            atmfAtmServiceConnInfoTable_oid,
                                            OID_LENGTH
                                            (atmfAtmServiceConnInfoTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfAtmServicePortIndex */
                                     ASN_INTEGER,       /* index: atmfAtmServiceVpi */
                                     ASN_INTEGER,       /* index: atmfAtmServiceVci */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 8;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        atmfAtmServiceConnInfoTable_get_first_data_point;
    iinfo->get_next_data_point =
        atmfAtmServiceConnInfoTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfAtmServiceConnInfoTable",
                "Registering table atmfAtmServiceConnInfoTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFATMSERVICECONNINFOTABLE */
#ifdef DO_ATMFNETPREFIXTABLE
/** Initialize the atmfNetPrefixTable table by defining its contents and how it's structured */
void
initialize_table_atmfNetPrefixTable(void)
{
    static oid      atmfNetPrefixTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 7, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("atmfNetPrefixTable",
                                                     atmfNetPrefixTable_handler,
                                                     atmfNetPrefixTable_oid,
                                                     OID_LENGTH
                                                     (atmfNetPrefixTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfNetPrefixPort */
                                     ASN_OCTET_STR,     /* index: atmfNetPrefixPrefix */
                                     0);

    table_info->min_column = 3;
    table_info->max_column = 3;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = atmfNetPrefixTable_get_first_data_point;
    iinfo->get_next_data_point = atmfNetPrefixTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfNetPrefixTable",
                "Registering table atmfNetPrefixTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFNETPREFIXTABLE */
#ifdef DO_ATMFVCCABRTABLE
/** Initialize the atmfVccAbrTable table by defining its contents and how it's structured */
void
initialize_table_atmfVccAbrTable(void)
{
    static oid      atmfVccAbrTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 10, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("atmfVccAbrTable",
                                                     atmfVccAbrTable_handler,
                                                     atmfVccAbrTable_oid,
                                                     OID_LENGTH
                                                     (atmfVccAbrTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfVccAbrPortIndex */
                                     ASN_INTEGER,       /* index: atmfVccAbrVpi */
                                     ASN_INTEGER,       /* index: atmfVccAbrVci */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 11;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = atmfVccAbrTable_get_first_data_point;
    iinfo->get_next_data_point = atmfVccAbrTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfVccAbrTable",
                "Registering table atmfVccAbrTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFVCCABRTABLE */
#ifdef DO_ATMFAAL5PROFILETABLE
/** Initialize the atmfAAL5ProfileTable table by defining its contents and how it's structured */
void
initialize_table_atmfAAL5ProfileTable(void)
{
    static oid      atmfAAL5ProfileTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 12, 5 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("atmfAAL5ProfileTable",
                                            atmfAAL5ProfileTable_handler,
                                            atmfAAL5ProfileTable_oid,
                                            OID_LENGTH
                                            (atmfAAL5ProfileTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfAAL5ProfileIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 5;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        atmfAAL5ProfileTable_get_first_data_point;
    iinfo->get_next_data_point = atmfAAL5ProfileTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfAAL5ProfileTable",
                "Registering table atmfAAL5ProfileTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFAAL5PROFILETABLE */
#ifdef DO_ATMFATMSERVICECONNINFOEXTENSIONTABLE
/** Initialize the atmfAtmServiceConnInfoExtensionTable table by defining its contents and how it's structured */
void
initialize_table_atmfAtmServiceConnInfoExtensionTable(void)
{
    static oid      atmfAtmServiceConnInfoExtensionTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 12, 9 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration
        ("atmfAtmServiceConnInfoExtensionTable",
         atmfAtmServiceConnInfoExtensionTable_handler,
         atmfAtmServiceConnInfoExtensionTable_oid,
         OID_LENGTH(atmfAtmServiceConnInfoExtensionTable_oid),
         HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, 0);

    table_info->min_column = 1;
    table_info->max_column = 1;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        atmfAtmServiceConnInfoExtensionTable_get_first_data_point;
    iinfo->get_next_data_point =
        atmfAtmServiceConnInfoExtensionTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfAtmServiceConnInfoExtensionTable",
                "Registering table atmfAtmServiceConnInfoExtensionTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFATMSERVICECONNINFOEXTENSIONTABLE */
#ifdef DO_ATMFAAL34PROFILETABLE
/** Initialize the atmfAAL34ProfileTable table by defining its contents and how it's structured */
void
initialize_table_atmfAAL34ProfileTable(void)
{
    static oid      atmfAAL34ProfileTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 12, 4 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("atmfAAL34ProfileTable",
                                            atmfAAL34ProfileTable_handler,
                                            atmfAAL34ProfileTable_oid,
                                            OID_LENGTH
                                            (atmfAAL34ProfileTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfAAL34ProfileIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 7;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        atmfAAL34ProfileTable_get_first_data_point;
    iinfo->get_next_data_point = atmfAAL34ProfileTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfAAL34ProfileTable",
                "Registering table atmfAAL34ProfileTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFAAL34PROFILETABLE */
#ifdef DO_ATMFSRVCREGTABLE
/** Initialize the atmfSrvcRegTable table by defining its contents and how it's structured */
void
initialize_table_atmfSrvcRegTable(void)
{
    static oid      atmfSrvcRegTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 8, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("atmfSrvcRegTable",
                                                     atmfSrvcRegTable_handler,
                                                     atmfSrvcRegTable_oid,
                                                     OID_LENGTH
                                                     (atmfSrvcRegTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfSrvcRegPort */
                                     ASN_OBJECT_ID,     /* index: atmfSrvcRegServiceID */
                                     ASN_INTEGER,       /* index: atmfSrvcRegAddressIndex */
                                     0);

    table_info->min_column = 3;
    table_info->max_column = 5;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = atmfSrvcRegTable_get_first_data_point;
    iinfo->get_next_data_point = atmfSrvcRegTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfSrvcRegTable",
                "Registering table atmfSrvcRegTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFSRVCREGTABLE */
#ifdef DO_ATMFADDRESSREGISTRATIONADMINTABLE
/** Initialize the atmfAddressRegistrationAdminTable table by defining its contents and how it's structured */
void
initialize_table_atmfAddressRegistrationAdminTable(void)
{
    static oid      atmfAddressRegistrationAdminTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 11, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration
        ("atmfAddressRegistrationAdminTable",
         atmfAddressRegistrationAdminTable_handler,
         atmfAddressRegistrationAdminTable_oid,
         OID_LENGTH(atmfAddressRegistrationAdminTable_oid),
         HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfAddressRegistrationAdminIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 2;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        atmfAddressRegistrationAdminTable_get_first_data_point;
    iinfo->get_next_data_point =
        atmfAddressRegistrationAdminTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfAddressRegistrationAdminTable",
                "Registering table atmfAddressRegistrationAdminTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFADDRESSREGISTRATIONADMINTABLE */
#ifdef DO_ATMFATMSTATSTABLE
/** Initialize the atmfAtmStatsTable table by defining its contents and how it's structured */
void
initialize_table_atmfAtmStatsTable(void)
{
    static oid      atmfAtmStatsTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 3, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("atmfAtmStatsTable",
                                                     atmfAtmStatsTable_handler,
                                                     atmfAtmStatsTable_oid,
                                                     OID_LENGTH
                                                     (atmfAtmStatsTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfAtmStatsIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 4;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = atmfAtmStatsTable_get_first_data_point;
    iinfo->get_next_data_point = atmfAtmStatsTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfAtmStatsTable",
                "Registering table atmfAtmStatsTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFATMSTATSTABLE */
#ifdef DO_ATMFAAL5PROFILEEXTENSIONTABLE
/** Initialize the atmfAAL5ProfileExtensionTable table by defining its contents and how it's structured */
void
initialize_table_atmfAAL5ProfileExtensionTable(void)
{
    static oid      atmfAAL5ProfileExtensionTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 12, 11 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration
        ("atmfAAL5ProfileExtensionTable",
         atmfAAL5ProfileExtensionTable_handler,
         atmfAAL5ProfileExtensionTable_oid,
         OID_LENGTH(atmfAAL5ProfileExtensionTable_oid),
         HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, 0);

    table_info->min_column = 1;
    table_info->max_column = 1;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        atmfAAL5ProfileExtensionTable_get_first_data_point;
    iinfo->get_next_data_point =
        atmfAAL5ProfileExtensionTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfAAL5ProfileExtensionTable",
                "Registering table atmfAAL5ProfileExtensionTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFAAL5PROFILEEXTENSIONTABLE */
#ifdef DO_ATMFAAL2COMMONPROFILETABLE
/** Initialize the atmfAAL2CommonProfileTable table by defining its contents and how it's structured */
void
initialize_table_atmfAAL2CommonProfileTable(void)
{
    static oid      atmfAAL2CommonProfileTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 12, 6 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("atmfAAL2CommonProfileTable",
                                            atmfAAL2CommonProfileTable_handler,
                                            atmfAAL2CommonProfileTable_oid,
                                            OID_LENGTH
                                            (atmfAAL2CommonProfileTable_oid),
                                            HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfAAL2ProfileIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 25;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        atmfAAL2CommonProfileTable_get_first_data_point;
    iinfo->get_next_data_point =
        atmfAAL2CommonProfileTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfAAL2CommonProfileTable",
                "Registering table atmfAAL2CommonProfileTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFAAL2COMMONPROFILETABLE */
#ifdef DO_ATMFVPCTABLE
/** Initialize the atmfVpcTable table by defining its contents and how it's structured */
void
initialize_table_atmfVpcTable(void)
{
    static oid      atmfVpcTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 4, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("atmfVpcTable",
                                                     atmfVpcTable_handler,
                                                     atmfVpcTable_oid,
                                                     OID_LENGTH
                                                     (atmfVpcTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfVpcPortIndex */
                                     ASN_INTEGER,       /* index: atmfVpcVpi */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 20;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = atmfVpcTable_get_first_data_point;
    iinfo->get_next_data_point = atmfVpcTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfVpcTable",
                "Registering table atmfVpcTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFVPCTABLE */
#ifdef DO_ATMFATMLAYERTABLE
/** Initialize the atmfAtmLayerTable table by defining its contents and how it's structured */
void
initialize_table_atmfAtmLayerTable(void)
{
    static oid      atmfAtmLayerTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 2, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("atmfAtmLayerTable",
                                                     atmfAtmLayerTable_handler,
                                                     atmfAtmLayerTable_oid,
                                                     OID_LENGTH
                                                     (atmfAtmLayerTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfAtmLayerIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 15;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = atmfAtmLayerTable_get_first_data_point;
    iinfo->get_next_data_point = atmfAtmLayerTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfAtmLayerTable",
                "Registering table atmfAtmLayerTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFATMLAYERTABLE */
#ifdef DO_ATMFADDRESSTABLE
/** Initialize the atmfAddressTable table by defining its contents and how it's structured */
void
initialize_table_atmfAddressTable(void)
{
    static oid      atmfAddressTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 6, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("atmfAddressTable",
                                                     atmfAddressTable_handler,
                                                     atmfAddressTable_oid,
                                                     OID_LENGTH
                                                     (atmfAddressTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfAddressPort */
                                     ASN_OCTET_STR,     /* index: atmfAddressAtmAddress */
                                     0);

    table_info->min_column = 3;
    table_info->max_column = 4;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = atmfAddressTable_get_first_data_point;
    iinfo->get_next_data_point = atmfAddressTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfAddressTable",
                "Registering table atmfAddressTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFADDRESSTABLE */
#ifdef DO_ATMFPORTTABLE
/** Initialize the atmfPortTable table by defining its contents and how it's structured */
void
initialize_table_atmfPortTable(void)
{
    static oid      atmfPortTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 1, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("atmfPortTable",
                                                     atmfPortTable_handler,
                                                     atmfPortTable_oid,
                                                     OID_LENGTH
                                                     (atmfPortTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfPortIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 8;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = atmfPortTable_get_first_data_point;
    iinfo->get_next_data_point = atmfPortTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfPortTable",
                "Registering table atmfPortTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFPORTTABLE */
#ifdef DO_ATMFVCCTABLE
/** Initialize the atmfVccTable table by defining its contents and how it's structured */
void
initialize_table_atmfVccTable(void)
{
    static oid      atmfVccTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 5, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("atmfVccTable",
                                                     atmfVccTable_handler,
                                                     atmfVccTable_oid,
                                                     OID_LENGTH
                                                     (atmfVccTable_oid),
                                                     HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: atmfVccPortIndex */
                                     ASN_INTEGER,       /* index: atmfVccVpi */
                                     ASN_INTEGER,       /* index: atmfVccVci */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 23;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = atmfVccTable_get_first_data_point;
    iinfo->get_next_data_point = atmfVccTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfVccTable",
                "Registering table atmfVccTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFVCCTABLE */
#ifdef DO_ATMFATMSERVICETYPEEXTENSIONTABLE
/** Initialize the atmfAtmServiceTypeExtensionTable table by defining its contents and how it's structured */
void
initialize_table_atmfAtmServiceTypeExtensionTable(void)
{
    static oid      atmfAtmServiceTypeExtensionTable_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 12, 10 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration
        ("atmfAtmServiceTypeExtensionTable",
         atmfAtmServiceTypeExtensionTable_handler,
         atmfAtmServiceTypeExtensionTable_oid,
         OID_LENGTH(atmfAtmServiceTypeExtensionTable_oid),
         HANDLER_CAN_RWRITE);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    //    netsnmp_table_helper_add_indexes(table_info, 0);
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER, 0);   /* index: atmfAtmServiceTypeIndex */

    table_info->min_column = 1;
    table_info->max_column = 2; 

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point =
        atmfAtmServiceTypeExtensionTable_get_first_data_point;
    iinfo->get_next_data_point =
        atmfAtmServiceTypeExtensionTable_get_next_data_point;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_atmfAtmServiceTypeExtensionTable",
                "Registering table atmfAtmServiceTypeExtensionTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}
#endif                          /* DO_ATMFATMSERVICETYPEEXTENSIONTABLE */

/** Initializes the atmForum module */
void
init_atmForum(void)
{
    /*
     * here we initialize all the tables we're planning on supporting 
     */
#ifdef DO_ATMFAAL1PROFILETABLE
    initialize_table_atmfAAL1ProfileTable();
#endif                          /* DO_ATMFAAL1PROFILETABLE */
#ifdef DO_ATMFAAL2LESPROFILETABLE
    initialize_table_atmfAAL2LESProfileTable();
#endif                          /* DO_ATMFAAL2LESPROFILETABLE */
#ifdef DO_ATMFATMSERVICETYPETABLE
    initialize_table_atmfAtmServiceTypeTable();
#endif                          /* DO_ATMFATMSERVICETYPETABLE */
#ifdef DO_ATMFVPCABRTABLE
    initialize_table_atmfVpcAbrTable();
#endif                          /* DO_ATMFVPCABRTABLE */
#ifdef DO_ATMFAAL2TRUNKINGPROFILETABLE
    initialize_table_atmfAAL2TrunkingProfileTable();
#endif                          /* DO_ATMFAAL2TRUNKINGPROFILETABLE */
#ifdef DO_ATMFATMSERVICECONNINFOTABLE
    initialize_table_atmfAtmServiceConnInfoTable();
#endif                          /* DO_ATMFATMSERVICECONNINFOTABLE */
#ifdef DO_ATMFNETPREFIXTABLE
    initialize_table_atmfNetPrefixTable();
#endif                          /* DO_ATMFNETPREFIXTABLE */
#ifdef DO_ATMFVCCABRTABLE
    initialize_table_atmfVccAbrTable();
#endif                          /* DO_ATMFVCCABRTABLE */
#ifdef DO_ATMFAAL5PROFILETABLE
    initialize_table_atmfAAL5ProfileTable();
#endif                          /* DO_ATMFAAL5PROFILETABLE */
#ifdef DO_ATMFATMSERVICECONNINFOEXTENSIONTABLE
    initialize_table_atmfAtmServiceConnInfoExtensionTable();
#endif                          /* DO_ATMFATMSERVICECONNINFOEXTENSIONTABLE */
#ifdef DO_ATMFAAL34PROFILETABLE
    initialize_table_atmfAAL34ProfileTable();
#endif                          /* DO_ATMFAAL34PROFILETABLE */
#ifdef DO_ATMFSRVCREGTABLE
    initialize_table_atmfSrvcRegTable();
#endif                          /* DO_ATMFSRVCREGTABLE */
#ifdef DO_ATMFADDRESSREGISTRATIONADMINTABLE
    initialize_table_atmfAddressRegistrationAdminTable();
#endif                          /* DO_ATMFADDRESSREGISTRATIONADMINTABLE */
#ifdef DO_ATMFATMSTATSTABLE
    initialize_table_atmfAtmStatsTable();
#endif                          /* DO_ATMFATMSTATSTABLE */
#ifdef DO_ATMFAAL5PROFILEEXTENSIONTABLE
    initialize_table_atmfAAL5ProfileExtensionTable();
#endif                          /* DO_ATMFAAL5PROFILEEXTENSIONTABLE */
#ifdef DO_ATMFAAL2COMMONPROFILETABLE
    initialize_table_atmfAAL2CommonProfileTable();
#endif                          /* DO_ATMFAAL2COMMONPROFILETABLE */
#ifdef DO_ATMFVPCTABLE
    initialize_table_atmfVpcTable();
#endif                          /* DO_ATMFVPCTABLE */
#ifdef DO_ATMFATMLAYERTABLE
    initialize_table_atmfAtmLayerTable();
#endif                          /* DO_ATMFATMLAYERTABLE */
#ifdef DO_ATMFADDRESSTABLE
    initialize_table_atmfAddressTable();
#endif                          /* DO_ATMFADDRESSTABLE */
#ifdef DO_ATMFPORTTABLE
    initialize_table_atmfPortTable();
#endif                          /* DO_ATMFPORTTABLE */
#ifdef DO_ATMFVCCTABLE
    initialize_table_atmfVccTable();
#endif                          /* DO_ATMFVCCTABLE */
#ifdef DO_ATMFATMSERVICETYPEEXTENSIONTABLE
    initialize_table_atmfAtmServiceTypeExtensionTable();
#endif                          /* DO_ATMFATMSERVICETYPEEXTENSIONTABLE */
    init_atmfMySystemIdentifier();
}


#ifdef DO_ATMFAAL1PROFILETABLE
/** returns the first data point within the atmfAAL1ProfileTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfAAL1ProfileTable_get_first_data_point(void **my_loop_context,
                                          void **my_data_context,
                                          netsnmp_variable_list *
                                          put_index_data,
                                          netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFAAL1PROFILETABLE *pData;

    /*
     * initialization here 
     */

    atmForumMibHelper_fillatmfAAL1ProfileTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAAL1ProfileIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAAL1ProfileIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfAAL1ProfileTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfAAL1ProfileTable_get_next_data_point(void **my_loop_context,
                                         void **my_data_context,
                                         netsnmp_variable_list *
                                         put_index_data,
                                         netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFAAL1PROFILETABLE *pData;

    pData = (ATM_FORUM_MIB_ATMFAAL1PROFILETABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAAL1ProfileIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAAL1ProfileIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfAAL1ProfileTable table, if anything else needs to be done */
int
atmfAAL1ProfileTable_handler(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFAAL1PROFILETABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfAAL1ProfileTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFAAL1PROFILETABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFAAL1PROFILEINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL1SUBTYPE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL1CBRRATE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL1CLKRECOVERYTYPE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL1FEC:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL1SDT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL1PARTIALLYFILLEDCELLS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL1CELLLOSSINTEGRPERIOD:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfAAL1ProfileTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfAAL1ProfileTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFAAL1PROFILETABLE */

#ifdef DO_ATMFAAL2LESPROFILETABLE
/** returns the first data point within the atmfAAL2LESProfileTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfAAL2LESProfileTable_get_first_data_point(void **my_loop_context,
                                             void **my_data_context,
                                             netsnmp_variable_list *
                                             put_index_data,
                                             netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFAAL2LESPROFILETABLE *pData;

    /*
     * initialization here 
     */

    atmForumMibHelper_fillatmfAAL2LESProfileTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAAL2ProfileIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAAL2ProfileIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfAAL2LESProfileTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfAAL2LESProfileTable_get_next_data_point(void **my_loop_context,
                                            void **my_data_context,
                                            netsnmp_variable_list *
                                            put_index_data,
                                            netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFAAL2LESPROFILETABLE *pData;

    pData = (ATM_FORUM_MIB_ATMFAAL2LESPROFILETABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAAL2ProfileIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAAL2ProfileIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfAAL2LESProfileTable table, if anything else needs to be done */
int
atmfAAL2LESProfileTable_handler(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFAAL2LESPROFILETABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfAAL2LESProfileTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFAAL2LESPROFILETABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFAAL2CPSCIDLOWERLIMIT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2CPSCIDUPPERLIMIT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2CPSOPTIMISATION:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfAAL2LESProfileTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfAAL2LESProfileTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFAAL2LESPROFILETABLE */

#ifdef DO_ATMFATMSERVICETYPETABLE
/** returns the first data point within the atmfAtmServiceTypeTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfAtmServiceTypeTable_get_first_data_point(void **my_loop_context,
                                             void **my_data_context,
                                             netsnmp_variable_list *
                                             put_index_data,
                                             netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFATMSERVICETYPETABLE *pData;
    int totalVccCount;

    /* assuming one service per ATM VC connection */
    totalVccCount = atmMibHelper_getTotalVccCount();
    if (totalVccCount > 0) {
      pData = calloc( totalVccCount, sizeof(ATM_FORUM_MIB_ATMFATMSERVICETYPETABLE));
      if (pData == NULL)
        return NULL;
    }
    else
      return NULL;

    atmForumMibHelper_fillatmfAtmServiceTypeTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfAtmServiceTypeIndex),
                       sizeof(pData->atmfAtmServiceTypeIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfAtmServiceTypeTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfAtmServiceTypeTable_get_next_data_point(void **my_loop_context,
                                            void **my_data_context,
                                            netsnmp_variable_list *
                                            put_index_data,
                                            netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFATMSERVICETYPETABLE *pData;

    pData = (ATM_FORUM_MIB_ATMFATMSERVICETYPETABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfAtmServiceTypeIndex),
                       sizeof(pData->atmfAtmServiceTypeIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfAtmServiceTypeTable table, if anything else needs to be done */
int
atmfAtmServiceTypeTable_handler(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFATMSERVICETYPETABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfAtmServiceTypeTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFATMSERVICETYPETABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFATMSERVICETYPEINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAtmServiceTypeIndex,
                                         sizeof(pData->atmfAtmServiceTypeIndex));
                break;

            case COLUMN_ATMFATMSERVICEPROVIDERNAME:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)pData->atmfAtmServiceProviderName,
                                         pData->atmfAtmServiceProviderName_len);
                break;

            case COLUMN_ATMFATMSERVICENAME:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)pData->atmfAtmServiceName,
                                         pData->atmfAtmServiceName_len);
                break;

            case COLUMN_ATMFATMSERVICESUBNAME:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)pData->atmfAtmServiceSubName,
                                         pData->atmfAtmServiceSubName_len);
                break;

            case COLUMN_ATMFATMSERVICECLIENT:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)pData->atmfAtmServiceClient,
                                         pData->atmfAtmServiceClient_len);
                break;

            case COLUMN_ATMFATMSERVICETMCATEGORY:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAtmServiceTMCategory,
                                         sizeof(pData->atmfAtmServiceTMCategory));
                break;

            case COLUMN_ATMFATMSERVICETMCONFORMANCEDEF:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAtmServiceTMConformanceDef,
                                         sizeof(pData->atmfAtmServiceTMConformanceDef));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfAtmServiceTypeTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfAtmServiceTypeTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFATMSERVICETYPETABLE */

#ifdef DO_ATMFVPCABRTABLE
/** returns the first data point within the atmfVpcAbrTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfVpcAbrTable_get_first_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFVPCABRTABLE *pData;

    /*
     * initialization here 
     */

    atmForumMibHelper_fillatmfVpcAbrTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfVpcAbrPortIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfVpcAbrPortIndex data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->) /* XXX: atmfVpcAbrVpi data */
                       ,
                       sizeof(pData->)
                       /* XXX: length of atmfVpcAbrVpi data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfVpcAbrTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfVpcAbrTable_get_next_data_point(void **my_loop_context,
                                    void **my_data_context,
                                    netsnmp_variable_list * put_index_data,
                                    netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFVPCABRTABLE *pData;

    pData = (ATM_FORUM_MIB_ATMFVPCABRTABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfVpcAbrPortIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfVpcAbrPortIndex data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->) /* XXX: atmfVpcAbrVpi data */
                       ,
                       sizeof(pData->)
                       /* XXX: length of atmfVpcAbrVpi data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfVpcAbrTable table, if anything else needs to be done */
int
atmfVpcAbrTable_handler(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFVPCABRTABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfVpcAbrTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFVPCABRTABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFVPCABRPORTINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCABRVPI:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCABRTRANSMITICR:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCABRTRANSMITNRM:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCABRTRANSMITTRM:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCABRTRANSMITCDF:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCABRTRANSMITRIF:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCABRTRANSMITRDF:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCABRTRANSMITADTF:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCABRTRANSMITCRM:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfVpcAbrTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfVpcAbrTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFVPCABRTABLE */

#ifdef DO_ATMFAAL2TRUNKINGPROFILETABLE
/** returns the first data point within the atmfAAL2TrunkingProfileTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfAAL2TrunkingProfileTable_get_first_data_point(void **my_loop_context,
                                                  void **my_data_context,
                                                  netsnmp_variable_list *
                                                  put_index_data,
                                                  netsnmp_iterator_info
                                                  *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFAAL2TRUNKINGPROFILETABLE *pData;

    /*
     * initialization here 
     */

    atmForumMibHelper_fillatmfAAL2TrunkingProfileTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAAL2ProfileIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAAL2ProfileIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfAAL2TrunkingProfileTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfAAL2TrunkingProfileTable_get_next_data_point(void **my_loop_context,
                                                 void **my_data_context,
                                                 netsnmp_variable_list *
                                                 put_index_data,
                                                 netsnmp_iterator_info
                                                 *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFAAL2TRUNKINGPROFILETABLE *pData;

    pData =
        (ATM_FORUM_MIB_ATMFAAL2TRUNKINGPROFILETABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAAL2ProfileIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAAL2ProfileIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfAAL2TrunkingProfileTable table, if anything else needs to be done */
int
atmfAAL2TrunkingProfileTable_handler(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFAAL2TRUNKINGPROFILETABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfAAL2TrunkingProfileTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFAAL2TRUNKINGPROFILETABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFAAL2VCCI:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SIGNALINGVCCI:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfAAL2TrunkingProfileTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfAAL2TrunkingProfileTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFAAL2TRUNKINGPROFILETABLE */

#ifdef DO_ATMFATMSERVICECONNINFOTABLE
/** returns the first data point within the atmfAtmServiceConnInfoTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfAtmServiceConnInfoTable_get_first_data_point(void **my_loop_context,
                                                 void **my_data_context,
                                                 netsnmp_variable_list *
                                                 put_index_data,
                                                 netsnmp_iterator_info
                                                 *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFATMSERVICECONNINFOTABLE *pData;
    int totalVccCount;

    totalVccCount = atmMibHelper_getTotalVccCount();
    if (totalVccCount > 0) {
      pData = calloc( totalVccCount, sizeof(ATM_FORUM_MIB_ATMFATMSERVICECONNINFOTABLE));
      if (pData == NULL)
        return NULL;
    }
    else
      return NULL;

    atmForumMibHelper_fillatmfAtmServiceConnInfoTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfAtmServicePortIndex),
                       sizeof(pData->atmfAtmServicePortIndex));
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfAtmServiceVpi),
                       sizeof(pData->atmfAtmServiceVpi));
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfAtmServiceVci),
                       sizeof(pData->atmfAtmServiceVci));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfAtmServiceConnInfoTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfAtmServiceConnInfoTable_get_next_data_point(void **my_loop_context,
                                                void **my_data_context,
                                                netsnmp_variable_list *
                                                put_index_data,
                                                netsnmp_iterator_info
                                                *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFATMSERVICECONNINFOTABLE *pData;

    pData =
        (ATM_FORUM_MIB_ATMFATMSERVICECONNINFOTABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfAtmServicePortIndex),
                       sizeof(pData->atmfAtmServicePortIndex));
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfAtmServiceVpi),
                       sizeof(pData->atmfAtmServiceVpi));
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfAtmServiceVci),
                       sizeof(pData->atmfAtmServiceVci));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfAtmServiceConnInfoTable table, if anything else needs to be done */
int
atmfAtmServiceConnInfoTable_handler(netsnmp_mib_handler *handler,
                                    netsnmp_handler_registration *reginfo,
                                    netsnmp_agent_request_info *reqinfo,
                                    netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFATMSERVICECONNINFOTABLE *pData;

    DEBUGMSGTL(("atmfAtmServiceConnInfoTable_handler", "entry\n"));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfAtmServiceConnInfoTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFATMSERVICECONNINFOTABLE *)
            netsnmp_extract_iterator_context(request);

        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                DEBUGMSGTL(("atmfAtmServiceConnInfoTable_handler", "pData is NULL, noSuchName\n"));
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);

        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            DEBUGMSGTL(("atmfAtmServiceConnInfoTable_handler", "table_info is NULL\n"));
            continue;
        }
        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFATMSERVICEPORTINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAtmServicePortIndex,
                                         sizeof(pData->atmfAtmServicePortIndex));
                break;

            case COLUMN_ATMFATMSERVICEVPI:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAtmServiceVpi,
                                         sizeof(pData->atmfAtmServiceVpi));
                break;

            case COLUMN_ATMFATMSERVICEVCI:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAtmServiceVci,
                                         sizeof(pData->atmfAtmServiceVci));
                break;

            case COLUMN_ATMFATMSERVICESIGNALID:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAtmServiceSignalId,
                                         sizeof(pData->atmfAtmServiceSignalId));
                break;

            case COLUMN_ATMFATMSERVICECONNSERVICEINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAtmServiceConnServiceIndex,
                                         sizeof(pData->atmfAtmServiceConnServiceIndex));
                break;

            case COLUMN_ATMFATMSERVICECONNNAME:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)pData->atmfAtmServiceConnName,
                                         strlen(pData->atmfAtmServiceConnName));
                break;

            case COLUMN_ATMFATMSERVICECONNAALTYPE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAtmServiceConnAALType,
                                         sizeof(pData->atmfAtmServiceConnAALType));
                break;

            case COLUMN_ATMFATMSERVICECONNAALINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAtmServiceConnAALIndex,
                                         sizeof(pData->atmfAtmServiceConnAALIndex));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfAtmServiceConnInfoTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfAtmServiceConnInfoTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFATMSERVICECONNINFOTABLE */

#ifdef DO_ATMFNETPREFIXTABLE
/** returns the first data point within the atmfNetPrefixTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfNetPrefixTable_get_first_data_point(void **my_loop_context,
                                        void **my_data_context,
                                        netsnmp_variable_list *
                                        put_index_data,
                                        netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFNETPREFIXTABLE *pData;

    /*
     * initialization here 
     */

    atmForumMibHelper_fillatmfNetPrefixTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfNetPrefixPort data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfNetPrefixPort data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfNetPrefixPrefix data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfNetPrefixPrefix data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfNetPrefixTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfNetPrefixTable_get_next_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFNETPREFIXTABLE *pData;

    pData = (ATM_FORUM_MIB_ATMFNETPREFIXTABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfNetPrefixPort data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfNetPrefixPort data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfNetPrefixPrefix data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfNetPrefixPrefix data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfNetPrefixTable table, if anything else needs to be done */
int
atmfNetPrefixTable_handler(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFNETPREFIXTABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfNetPrefixTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFNETPREFIXTABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFNETPREFIXSTATUS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfNetPrefixTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfNetPrefixTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFNETPREFIXTABLE */

#ifdef DO_ATMFVCCABRTABLE
/** returns the first data point within the atmfVccAbrTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfVccAbrTable_get_first_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFVCCABRTABLE *pData;

    /*
     * initialization here 
     */

    atmForumMibHelper_fillatmfVccAbrTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfVccAbrPortIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfVccAbrPortIndex data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->) /* XXX: atmfVccAbrVpi data */
                       ,
                       sizeof(pData->)
                       /* XXX: length of atmfVccAbrVpi data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->) /* XXX: atmfVccAbrVci data */
                       ,
                       sizeof(pData->)
                       /* XXX: length of atmfVccAbrVci data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfVccAbrTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfVccAbrTable_get_next_data_point(void **my_loop_context,
                                    void **my_data_context,
                                    netsnmp_variable_list * put_index_data,
                                    netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFVCCABRTABLE *pData;

    pData = (ATM_FORUM_MIB_ATMFVCCABRTABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfVccAbrPortIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfVccAbrPortIndex data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->) /* XXX: atmfVccAbrVpi data */
                       ,
                       sizeof(pData->)
                       /* XXX: length of atmfVccAbrVpi data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->) /* XXX: atmfVccAbrVci data */
                       ,
                       sizeof(pData->)
                       /* XXX: length of atmfVccAbrVci data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfVccAbrTable table, if anything else needs to be done */
int
atmfVccAbrTable_handler(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFVCCABRTABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfVccAbrTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFVCCABRTABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFVCCABRPORTINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVCCABRVPI:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVCCABRVCI:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVCCABRTRANSMITICR:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVCCABRTRANSMITNRM:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVCCABRTRANSMITTRM:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVCCABRTRANSMITCDF:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVCCABRTRANSMITRIF:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVCCABRTRANSMITRDF:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVCCABRTRANSMITADTF:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVCCABRTRANSMITCRM:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfVccAbrTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfVccAbrTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFVCCABRTABLE */

#ifdef DO_ATMFAAL5PROFILETABLE
/** returns the first data point within the atmfAAL5ProfileTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfAAL5ProfileTable_get_first_data_point(void **my_loop_context,
                                          void **my_data_context,
                                          netsnmp_variable_list *
                                          put_index_data,
                                          netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFAAL5PROFILETABLE *pData;
    int totalAal5Profile;

    /* assuming one profile per ATM VC connection */
    totalAal5Profile = atmMibHelper_getTotalVccCount();
    if (totalAal5Profile > 0) {
      pData = calloc(totalAal5Profile, sizeof(ATM_FORUM_MIB_ATMFAAL5PROFILETABLE));    
      if (pData == NULL)
        return NULL;
    }
    else
      return NULL;
    
    atmForumMibHelper_fillatmfAAL5ProfileTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfAAL5ProfileIndex),
                       sizeof(pData->atmfAAL5ProfileIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfAAL5ProfileTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfAAL5ProfileTable_get_next_data_point(void **my_loop_context,
                                         void **my_data_context,
                                         netsnmp_variable_list *
                                         put_index_data,
                                         netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFAAL5PROFILETABLE *pData;

    pData = (ATM_FORUM_MIB_ATMFAAL5PROFILETABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfAAL5ProfileIndex),
                       sizeof(pData->atmfAAL5ProfileIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfAAL5ProfileTable table, if anything else needs to be done */
int
atmfAAL5ProfileTable_handler(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFAAL5PROFILETABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfAAL5ProfileTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFAAL5PROFILETABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFAAL5PROFILEINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAAL5ProfileIndex,
                                         sizeof(pData->atmfAAL5ProfileIndex));
                break;

            case COLUMN_ATMFAAL5MAXCPCSSDUSIZEFORWARD:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAAL5MaxCpcsSduSizeForward,
                                         sizeof(pData->atmfAAL5MaxCpcsSduSizeForward));
                break;

            case COLUMN_ATMFAAL5MAXCPCSSDUSIZEBACKWARD:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAAL5MaxCpcsSduSizeBackward,
                                         sizeof(pData->atmfAAL5MaxCpcsSduSizeBackward));
                break;

            case COLUMN_ATMFAAL5AALMODE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAAL5AALMode,
                                         sizeof(pData->atmfAAL5AALMode));
                break;

            case COLUMN_ATMFAAL5SSCSTYPE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAAL5SscsType,
                                         sizeof(pData->atmfAAL5SscsType));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfAAL5ProfileTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfAAL5ProfileTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFAAL5PROFILETABLE */

#ifdef DO_ATMFATMSERVICECONNINFOEXTENSIONTABLE
/** returns the first data point within the atmfAtmServiceConnInfoExtensionTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfAtmServiceConnInfoExtensionTable_get_first_data_point(void
                                                          **my_loop_context,
                                                          void
                                                          **my_data_context,
                                                          netsnmp_variable_list
                                                          * put_index_data,
                                                          netsnmp_iterator_info
                                                          *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFATMSERVICECONNINFOEXTENSIONTABLE *pData;

    /*
     * initialization here 
     */
    pData = malloc(sizeof(ATM_FORUM_MIB_ATMFATMSERVICECONNINFOEXTENSIONTABLE));
    atmForumMibHelper_fillatmfAtmServiceConnInfoExtensionTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    return put_index_data;
}

/** functionally the same as atmfAtmServiceConnInfoExtensionTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfAtmServiceConnInfoExtensionTable_get_next_data_point(void
                                                         **my_loop_context,
                                                         void
                                                         **my_data_context,
                                                         netsnmp_variable_list
                                                         * put_index_data,
                                                         netsnmp_iterator_info
                                                         *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFATMSERVICECONNINFOEXTENSIONTABLE *pData;

    pData =
        (ATM_FORUM_MIB_ATMFATMSERVICECONNINFOEXTENSIONTABLE *) *
        my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    return put_index_data;
}

/** handles requests for the atmfAtmServiceConnInfoExtensionTable table, if anything else needs to be done */
int
atmfAtmServiceConnInfoExtensionTable_handler(netsnmp_mib_handler *handler,
                                             netsnmp_handler_registration
                                             *reginfo,
                                             netsnmp_agent_request_info
                                             *reqinfo,
                                             netsnmp_request_info
                                             *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFATMSERVICECONNINFOEXTENSIONTABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfAtmServiceConnInfoExtensionTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFATMSERVICECONNINFOEXTENSIONTABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFATMSERVICEPHYMACIDENTIFIER:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *)&pData->atmfAtmServicePhyMacIdentifier,
                                         sizeof(pData->atmfAtmServicePhyMacIdentifier));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfAtmServiceConnInfoExtensionTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfAtmServiceConnInfoExtensionTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFATMSERVICECONNINFOEXTENSIONTABLE */

#ifdef DO_ATMFAAL34PROFILETABLE
/** returns the first data point within the atmfAAL34ProfileTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfAAL34ProfileTable_get_first_data_point(void **my_loop_context,
                                           void **my_data_context,
                                           netsnmp_variable_list *
                                           put_index_data,
                                           netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFAAL34PROFILETABLE *pData;

    /*
     * initialization here 
     */

    atmForumMibHelper_fillatmfAAL34ProfileTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAAL34ProfileIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAAL34ProfileIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfAAL34ProfileTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfAAL34ProfileTable_get_next_data_point(void **my_loop_context,
                                          void **my_data_context,
                                          netsnmp_variable_list *
                                          put_index_data,
                                          netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFAAL34PROFILETABLE *pData;

    pData = (ATM_FORUM_MIB_ATMFAAL34PROFILETABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAAL34ProfileIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAAL34ProfileIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfAAL34ProfileTable table, if anything else needs to be done */
int
atmfAAL34ProfileTable_handler(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFAAL34PROFILETABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfAAL34ProfileTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFAAL34PROFILETABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFAAL34PROFILEINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL34MAXCPCSSDUSIZEFORWARD:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL34MAXCPCSSDUSIZEBACKWARD:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL34MIDRANGELOW:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL34MIDRANGEHIGH:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL34AALMODE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL34SSCSTYPE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfAAL34ProfileTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfAAL34ProfileTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFAAL34PROFILETABLE */

#ifdef DO_ATMFSRVCREGTABLE
/** returns the first data point within the atmfSrvcRegTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfSrvcRegTable_get_first_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFSRVCREGTABLE *pData;

    /*
     * initialization here 
     */

    atmForumMibHelper_fillatmfSrvcRegTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfSrvcRegPort data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfSrvcRegPort data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfSrvcRegServiceID data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfSrvcRegServiceID data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfSrvcRegAddressIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfSrvcRegAddressIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfSrvcRegTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfSrvcRegTable_get_next_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFSRVCREGTABLE *pData;

    pData = (ATM_FORUM_MIB_ATMFSRVCREGTABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfSrvcRegPort data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfSrvcRegPort data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfSrvcRegServiceID data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfSrvcRegServiceID data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfSrvcRegAddressIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfSrvcRegAddressIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfSrvcRegTable table, if anything else needs to be done */
int
atmfSrvcRegTable_handler(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFSRVCREGTABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfSrvcRegTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFSRVCREGTABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFSRVCREGATMADDRESS:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFSRVCREGPARM1:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfSrvcRegTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfSrvcRegTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFSRVCREGTABLE */

#ifdef DO_ATMFADDRESSREGISTRATIONADMINTABLE
/** returns the first data point within the atmfAddressRegistrationAdminTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfAddressRegistrationAdminTable_get_first_data_point(void
                                                       **my_loop_context,
                                                       void
                                                       **my_data_context,
                                                       netsnmp_variable_list
                                                       * put_index_data,
                                                       netsnmp_iterator_info
                                                       *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFADDRESSREGISTRATIONADMINTABLE *pData;

    /*
     * initialization here 
     */

    atmForumMibHelper_fillatmfAddressRegistrationAdminTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAddressRegistrationAdminIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAddressRegistrationAdminIndex data */
                       );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfAddressRegistrationAdminTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfAddressRegistrationAdminTable_get_next_data_point(void
                                                      **my_loop_context,
                                                      void
                                                      **my_data_context,
                                                      netsnmp_variable_list
                                                      * put_index_data,
                                                      netsnmp_iterator_info
                                                      *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFADDRESSREGISTRATIONADMINTABLE *pData;

    pData =
        (ATM_FORUM_MIB_ATMFADDRESSREGISTRATIONADMINTABLE *) *
        my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAddressRegistrationAdminIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAddressRegistrationAdminIndex data */
                       );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfAddressRegistrationAdminTable table, if anything else needs to be done */
int
atmfAddressRegistrationAdminTable_handler(netsnmp_mib_handler *handler,
                                          netsnmp_handler_registration
                                          *reginfo,
                                          netsnmp_agent_request_info
                                          *reqinfo,
                                          netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFADDRESSREGISTRATIONADMINTABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfAddressRegistrationAdminTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFADDRESSREGISTRATIONADMINTABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFADDRESSREGISTRATIONADMININDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFADDRESSREGISTRATIONADMINSTATUS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfAddressRegistrationAdminTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfAddressRegistrationAdminTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFADDRESSREGISTRATIONADMINTABLE */

#ifdef DO_ATMFATMSTATSTABLE
/** returns the first data point within the atmfAtmStatsTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfAtmStatsTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFATMSTATSTABLE *pData;

    /*
     * initialization here 
     */

    atmForumMibHelper_fillatmfAtmStatsTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAtmStatsIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAtmStatsIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfAtmStatsTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfAtmStatsTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFATMSTATSTABLE *pData;

    pData = (ATM_FORUM_MIB_ATMFATMSTATSTABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAtmStatsIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAtmStatsIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfAtmStatsTable table, if anything else needs to be done */
int
atmfAtmStatsTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFATMSTATSTABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfAtmStatsTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFATMSTATSTABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFATMSTATSINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFATMSTATSRECEIVEDCELLS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFATMSTATSDROPPEDRECEIVEDCELLS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFATMSTATSTRANSMITTEDCELLS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfAtmStatsTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfAtmStatsTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFATMSTATSTABLE */

#ifdef DO_ATMFAAL5PROFILEEXTENSIONTABLE
/** returns the first data point within the atmfAAL5ProfileExtensionTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfAAL5ProfileExtensionTable_get_first_data_point(void **my_loop_context,
                                                   void **my_data_context,
                                                   netsnmp_variable_list *
                                                   put_index_data,
                                                   netsnmp_iterator_info
                                                   *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFAAL5PROFILEEXTENSIONTABLE *pData;

    /*
     * initialization here 
     */

    atmForumMibHelper_fillatmfAAL5ProfileExtensionTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;


    return put_index_data;
}

/** functionally the same as atmfAAL5ProfileExtensionTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfAAL5ProfileExtensionTable_get_next_data_point(void **my_loop_context,
                                                  void **my_data_context,
                                                  netsnmp_variable_list *
                                                  put_index_data,
                                                  netsnmp_iterator_info
                                                  *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFAAL5PROFILEEXTENSIONTABLE *pData;

    pData =
        (ATM_FORUM_MIB_ATMFAAL5PROFILEEXTENSIONTABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;


    return put_index_data;
}

/** handles requests for the atmfAAL5ProfileExtensionTable table, if anything else needs to be done */
int
atmfAAL5ProfileExtensionTable_handler(netsnmp_mib_handler *handler,
                                      netsnmp_handler_registration
                                      *reginfo,
                                      netsnmp_agent_request_info *reqinfo,
                                      netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFAAL5PROFILEEXTENSIONTABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfAAL5ProfileExtensionTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFAAL5PROFILEEXTENSIONTABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFAAL5VCCI:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfAAL5ProfileExtensionTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfAAL5ProfileExtensionTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFAAL5PROFILEEXTENSIONTABLE */

#ifdef DO_ATMFAAL2COMMONPROFILETABLE
/** returns the first data point within the atmfAAL2CommonProfileTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfAAL2CommonProfileTable_get_first_data_point(void **my_loop_context,
                                                void **my_data_context,
                                                netsnmp_variable_list *
                                                put_index_data,
                                                netsnmp_iterator_info
                                                *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFAAL2COMMONPROFILETABLE *pData;

    /*
     * initialization here 
     */

    atmForumMibHelper_fillatmfAAL2CommonProfileTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAAL2ProfileIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAAL2ProfileIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfAAL2CommonProfileTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfAAL2CommonProfileTable_get_next_data_point(void **my_loop_context,
                                               void **my_data_context,
                                               netsnmp_variable_list *
                                               put_index_data,
                                               netsnmp_iterator_info
                                               *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFAAL2COMMONPROFILETABLE *pData;

    pData = (ATM_FORUM_MIB_ATMFAAL2COMMONPROFILETABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAAL2ProfileIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAAL2ProfileIndex data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfAAL2CommonProfileTable table, if anything else needs to be done */
int
atmfAAL2CommonProfileTable_handler(netsnmp_mib_handler *handler,
                                   netsnmp_handler_registration *reginfo,
                                   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFAAL2COMMONPROFILETABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfAAL2CommonProfileTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFAAL2COMMONPROFILETABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFAAL2PROFILEINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2APPLICATIONIDENTIFIER:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2CONFIGRESPONSIBILITY:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2CPSMAXMULTIPLEXEDCHANNELS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2CPSMAXSDULENGTH:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSMAXSSSARSDULENGTH:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSSSTEDSTATUS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSSSADTSTATUS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSSERVICECATEGORY:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSAUDIOSERVICETRANSPORT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSPROFILESOURCE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSIEEEOUI:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSPREDEFINEDPROFILEIDENTIFIER:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSPCMENCODING:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSFAXDEMODULATIONTRANSPORT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSCASSIGNALINGTRANSPORT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSDTMFDIGITPACKETTRANSPORT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSMFR1DIGITPACKETTRANSPORT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSMFR2DIGITPACKETTRANSPORT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSCIRCUITMODEDATATRANSPORT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSCIRCUITMODEDATANUMCHANNELS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSFRAMEMODEDATATRANSPORT:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCSFRAMEMODEDATAMAXLENGTH:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCOPSDULENGTH:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFAAL2SSCOPUUFIELDLENGTH:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfAAL2CommonProfileTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfAAL2CommonProfileTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFAAL2COMMONPROFILETABLE */

#ifdef DO_ATMFVPCTABLE
/** returns the first data point within the atmfVpcTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfVpcTable_get_first_data_point(void **my_loop_context,
                                  void **my_data_context,
                                  netsnmp_variable_list * put_index_data,
                                  netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFVPCTABLE *pData;

    /*
     * initialization here 
     */

    atmForumMibHelper_fillatmfVpcTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfVpcPortIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfVpcPortIndex data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->) /* XXX: atmfVpcVpi data */ ,
                       sizeof(pData->) /* XXX: length of atmfVpcVpi data */
                       );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfVpcTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfVpcTable_get_next_data_point(void **my_loop_context,
                                 void **my_data_context,
                                 netsnmp_variable_list * put_index_data,
                                 netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFVPCTABLE *pData;

    pData = (ATM_FORUM_MIB_ATMFVPCTABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfVpcPortIndex data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfVpcPortIndex data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->) /* XXX: atmfVpcVpi data */ ,
                       sizeof(pData->) /* XXX: length of atmfVpcVpi data */
                       );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfVpcTable table, if anything else needs to be done */
int
atmfVpcTable_handler(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFVPCTABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfVpcTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFVPCTABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFVPCPORTINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCVPI:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCOPERSTATUS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCTRANSMITTRAFFICDESCRIPTORTYPE:
                snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCTRANSMITTRAFFICDESCRIPTORPARAM1:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCTRANSMITTRAFFICDESCRIPTORPARAM2:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCTRANSMITTRAFFICDESCRIPTORPARAM3:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCTRANSMITTRAFFICDESCRIPTORPARAM4:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCTRANSMITTRAFFICDESCRIPTORPARAM5:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCRECEIVETRAFFICDESCRIPTORTYPE:
                snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCRECEIVETRAFFICDESCRIPTORPARAM1:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCRECEIVETRAFFICDESCRIPTORPARAM2:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCRECEIVETRAFFICDESCRIPTORPARAM3:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCRECEIVETRAFFICDESCRIPTORPARAM4:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCRECEIVETRAFFICDESCRIPTORPARAM5:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCQOSCATEGORY:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCTRANSMITQOSCLASS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCRECEIVEQOSCLASS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCBESTEFFORTINDICATOR:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFVPCSERVICECATEGORY:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfVpcTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfVpcTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFVPCTABLE */

#ifdef DO_ATMFATMLAYERTABLE
/** returns the first data point within the atmfAtmLayerTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfAtmLayerTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFATMLAYERTABLE *pData;

    /*
     * initialization here 
     */
    pData = calloc(1,sizeof(ATM_FORUM_MIB_ATMFATMLAYERTABLE));
    atmForumMibHelper_fillatmfAtmLayerTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfAtmLayerIndex),
                       sizeof(pData->atmfAtmLayerIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfAtmLayerTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfAtmLayerTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFATMLAYERTABLE *pData;

    pData = (ATM_FORUM_MIB_ATMFATMLAYERTABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfAtmLayerIndex),
                       sizeof(pData->atmfAtmLayerIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfAtmLayerTable table, if anything else needs to be done */
int
atmfAtmLayerTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFATMLAYERTABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfAtmLayerTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFATMLAYERTABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFATMLAYERINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAtmLayerIndex,
                                         sizeof(pData->atmfAtmLayerIndex));
                break;

            case COLUMN_ATMFATMLAYERMAXVPCS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &pData->atmfAtmLayerMaxVPCs,
                                         sizeof(pData->atmfAtmLayerMaxVPCs));
                break;

            case COLUMN_ATMFATMLAYERMAXVCCS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &pData->atmfAtmLayerMaxVCCs,
                                         sizeof(pData->atmfAtmLayerMaxVCCs));
                break;

            case COLUMN_ATMFATMLAYERCONFIGUREDVPCS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &pData->atmfAtmLayerConfiguredVPCs,
                                         sizeof(pData->atmfAtmLayerConfiguredVPCs));
                break;

            case COLUMN_ATMFATMLAYERCONFIGUREDVCCS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &pData->atmfAtmLayerConfiguredVCCs,
                                         sizeof(pData->atmfAtmLayerConfiguredVCCs));
                break;

            case COLUMN_ATMFATMLAYERMAXVPIBITS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &pData->atmfAtmLayerMaxVpiBits,
                                         sizeof(pData->atmfAtmLayerMaxVpiBits));
                break;

            case COLUMN_ATMFATMLAYERMAXVCIBITS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &pData->atmfAtmLayerMaxVciBits,
                                         sizeof(pData->atmfAtmLayerMaxVciBits));
                break;

            case COLUMN_ATMFATMLAYERUNITYPE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &pData->atmfAtmLayerUniType,
                                         sizeof(pData->atmfAtmLayerUniType));
                break;

            case COLUMN_ATMFATMLAYERUNIVERSION:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &pData->atmfAtmLayerUniVersion,
                                         sizeof(pData->atmfAtmLayerUniVersion));
                break;

            case COLUMN_ATMFATMLAYERDEVICETYPE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &pData->atmfAtmLayerDeviceType,
                                         sizeof(pData->atmfAtmLayerDeviceType));
                break;

            case COLUMN_ATMFATMLAYERILMIVERSION:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &pData->atmfAtmLayerIlmiVersion,
                                         sizeof(pData->atmfAtmLayerIlmiVersion));
                break;

            case COLUMN_ATMFATMLAYERNNISIGVERSION:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &pData->atmfAtmLayerNniSigVersion,
                                         sizeof(pData->atmfAtmLayerNniSigVersion));
                break;

            case COLUMN_ATMFATMLAYERMAXSVPCVPI:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &pData->atmfAtmLayerMaxSvpcVpi,
                                         sizeof(pData->atmfAtmLayerMaxSvpcVpi));
                break;

            case COLUMN_ATMFATMLAYERMAXSVCCVPI:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &pData->atmfAtmLayerMaxSvccVpi,
                                         sizeof(pData->atmfAtmLayerMaxSvccVpi));
                break;

            case COLUMN_ATMFATMLAYERMINSVCCVCI:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfAtmLayerMinSvccVci,
                                         sizeof(pData->atmfAtmLayerMinSvccVci));

                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfAtmLayerTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfAtmLayerTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFATMLAYERTABLE */

#ifdef DO_ATMFADDRESSTABLE
/** returns the first data point within the atmfAddressTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfAddressTable_get_first_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFADDRESSTABLE *pData;

    /*
     * initialization here 
     */

    atmForumMibHelper_fillatmfAddressTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAddressPort data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAddressPort data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAddressAtmAddress data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAddressAtmAddress data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfAddressTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfAddressTable_get_next_data_point(void **my_loop_context,
                                     void **my_data_context,
                                     netsnmp_variable_list *
                                     put_index_data,
                                     netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFADDRESSTABLE *pData;

    pData = (ATM_FORUM_MIB_ATMFADDRESSTABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAddressPort data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAddressPort data */ );
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->)
                       /* XXX: atmfAddressAtmAddress data */ ,
                       sizeof(pData->)
                       /* XXX: length of atmfAddressAtmAddress data */ );
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfAddressTable table, if anything else needs to be done */
int
atmfAddressTable_handler(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFADDRESSTABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfAddressTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFADDRESSTABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFADDRESSSTATUS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            case COLUMN_ATMFADDRESSORGSCOPE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->
                                         /* XXX: column data */ ,
                                         sizeof(pData->
                                                /* XXX: column data length */
                                                ));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfAddressTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfAddressTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFADDRESSTABLE */

#ifdef DO_ATMFPORTTABLE
/** returns the first data point within the atmfPortTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfPortTable_get_first_data_point(void **my_loop_context,
                                   void **my_data_context,
                                   netsnmp_variable_list * put_index_data,
                                   netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFPORTTABLE *pData;

    pData = calloc(1, sizeof(ATM_FORUM_MIB_ATMFPORTTABLE));
    atmForumMibHelper_fillatmfPortTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfPortIndex),
                       sizeof(pData->atmfPortIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfPortTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfPortTable_get_next_data_point(void **my_loop_context,
                                  void **my_data_context,
                                  netsnmp_variable_list * put_index_data,
                                  netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFPORTTABLE *pData;

    pData = (ATM_FORUM_MIB_ATMFPORTTABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfPortIndex),
                       sizeof(pData->atmfPortIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfPortTable table, if anything else needs to be done */
int
atmfPortTable_handler(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFPORTTABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfPortTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFPORTTABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFPORTINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfPortIndex,
                                         sizeof(pData->atmfPortIndex));
                break;

            case COLUMN_ATMFPORTADDRESS:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,(u_char*)NULL,0);
                break;

            case COLUMN_ATMFPORTTRANSMISSIONTYPE:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,(u_char*)NULL,0);
                break;

            case COLUMN_ATMFPORTMEDIATYPE:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,(u_char*)NULL,0);
                break;

            case COLUMN_ATMFPORTOPERSTATUS:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,(u_char*)NULL,0);
                break;

            case COLUMN_ATMFPORTSPECIFIC:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,(u_char*)NULL,0);
                break;

            case COLUMN_ATMFPORTMYIFNAME:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)pData->atmfPortMyIfName,
                                         pData->atmfPortMyIfName_len);
                break;

            case COLUMN_ATMFPORTMYIFIDENTIFIER:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &pData->atmfPortMyIfIdentifier,
                                         sizeof(pData->atmfPortMyIfIdentifier));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfPortTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfPortTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFPORTTABLE */

#ifdef DO_ATMFVCCTABLE
/** returns the first data point within the atmfVccTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfVccTable_get_first_data_point(void **my_loop_context,
                                  void **my_data_context,
                                  netsnmp_variable_list * put_index_data,
                                  netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    int totalVccCount;
    ATM_FORUM_MIB_ATMFVCCTABLE *pData;

    totalVccCount = atmMibHelper_getTotalVccCount();
    if (totalVccCount > 0) {
      pData = calloc( totalVccCount, sizeof(ATM_FORUM_MIB_ATMFVCCTABLE));
      if (pData == NULL)
        return NULL;
    }
    else
      return NULL;

    atmForumMibHelper_fillatmfVccTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfVccPortIndex),
                       sizeof(pData->atmfVccPortIndex));
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfVccVpi),
                       sizeof(pData->atmfVccVpi));
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfVccVci),
                       sizeof(pData->atmfVccVci));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as atmfVccTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfVccTable_get_next_data_point(void **my_loop_context,
                                 void **my_data_context,
                                 netsnmp_variable_list * put_index_data,
                                 netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFVCCTABLE *pData;

    pData = (ATM_FORUM_MIB_ATMFVCCTABLE *) * my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfVccPortIndex),
                       sizeof(pData->atmfVccPortIndex));
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfVccVpi),
                       sizeof(pData->atmfVccVpi));
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->atmfVccVci),
                       sizeof(pData->atmfVccVci));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfVccTable table, if anything else needs to be done */
int
atmfVccTable_handler(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFVCCTABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfVccTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFVCCTABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFVCCPORTINDEX:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccPortIndex,
                                         sizeof(pData->atmfVccPortIndex));
                break;

            case COLUMN_ATMFVCCVPI:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccVpi,
                                         sizeof(pData->atmfVccVpi));
                break;

            case COLUMN_ATMFVCCVCI:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccVci,
                                         sizeof(pData->atmfVccVci));
                break;

            case COLUMN_ATMFVCCOPERSTATUS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccOperStatus,
                                         sizeof(pData->atmfVccOperStatus));
                break;

            case COLUMN_ATMFVCCTRANSMITTRAFFICDESCRIPTORTYPE:
                snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                         (u_char *) & pData->atmfVccTransmitTrafficDescriptorType,
                                         sizeof(pData->atmfVccTransmitTrafficDescriptorType));
                break;

            case COLUMN_ATMFVCCTRANSMITTRAFFICDESCRIPTORPARAM1:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccTransmitTrafficDescriptorParam1,
                                         sizeof(pData->atmfVccTransmitTrafficDescriptorParam1));
                break;

            case COLUMN_ATMFVCCTRANSMITTRAFFICDESCRIPTORPARAM2:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccTransmitTrafficDescriptorParam2,
                                         sizeof(pData->atmfVccTransmitTrafficDescriptorParam2));
                break;

            case COLUMN_ATMFVCCTRANSMITTRAFFICDESCRIPTORPARAM3:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccTransmitTrafficDescriptorParam3,
                                         sizeof(pData->atmfVccTransmitTrafficDescriptorParam3));
                break;

            case COLUMN_ATMFVCCTRANSMITTRAFFICDESCRIPTORPARAM4:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccTransmitTrafficDescriptorParam4,
                                         sizeof(pData->atmfVccTransmitTrafficDescriptorParam4));
                break;

            case COLUMN_ATMFVCCTRANSMITTRAFFICDESCRIPTORPARAM5:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccTransmitTrafficDescriptorParam5,
                                         sizeof(pData->atmfVccTransmitTrafficDescriptorParam5));
                break;

            case COLUMN_ATMFVCCRECEIVETRAFFICDESCRIPTORTYPE:
                snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                         (u_char *) & pData->atmfVccReceiveTrafficDescriptorType,
                                         sizeof(pData->atmfVccReceiveTrafficDescriptorType));
                break;

            case COLUMN_ATMFVCCRECEIVETRAFFICDESCRIPTORPARAM1:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccReceiveTrafficDescriptorParam1,
                                         sizeof(pData->atmfVccReceiveTrafficDescriptorParam1));
                break;

            case COLUMN_ATMFVCCRECEIVETRAFFICDESCRIPTORPARAM2:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccReceiveTrafficDescriptorParam2,
                                         sizeof(pData->atmfVccReceiveTrafficDescriptorParam2));
                break;

            case COLUMN_ATMFVCCRECEIVETRAFFICDESCRIPTORPARAM3:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccReceiveTrafficDescriptorParam3,
                                         sizeof(pData->atmfVccReceiveTrafficDescriptorParam3));
                break;

            case COLUMN_ATMFVCCRECEIVETRAFFICDESCRIPTORPARAM4:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccReceiveTrafficDescriptorParam4,
                                         sizeof(pData->atmfVccReceiveTrafficDescriptorParam4));
                break;

            case COLUMN_ATMFVCCRECEIVETRAFFICDESCRIPTORPARAM5:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccReceiveTrafficDescriptorParam5,
                                         sizeof(pData->atmfVccReceiveTrafficDescriptorParam5));
                break;

            case COLUMN_ATMFVCCQOSCATEGORY:
                /* according to ILMI spec. version 4.0., this object shouldn't be implemented */
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,(u_char*)NULL,0);
                break;

            case COLUMN_ATMFVCCTRANSMITQOSCLASS:
                /* according to ILMI spec. version 4.0., this object shouldn't be implemented */
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,(u_char*)NULL,0);
                break;

            case COLUMN_ATMFVCCRECEIVEQOSCLASS:
                /* according to ILMI spec. version 4.0., this object shouldn't be implemented */
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,(u_char*)NULL,0);
                break;

            case COLUMN_ATMFVCCBESTEFFORTINDICATOR:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccBestEffortIndicator,
                                         sizeof(pData->atmfVccBestEffortIndicator));
                break;

            case COLUMN_ATMFVCCTRANSMITFRAMEDISCARD:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccTransmitFrameDiscard,
                                         sizeof(pData->atmfVccTransmitFrameDiscard));
                break;

            case COLUMN_ATMFVCCRECEIVEFRAMEDISCARD:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccReceiveFrameDiscard,
                                         sizeof(pData->atmfVccReceiveFrameDiscard));
                break;

            case COLUMN_ATMFVCCSERVICECATEGORY:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) & pData->atmfVccServiceCategory,
                                         sizeof(pData->atmfVccServiceCategory));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfVccTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfVccTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFVCCTABLE */

#ifdef DO_ATMFATMSERVICETYPEEXTENSIONTABLE
/** returns the first data point within the atmfAtmServiceTypeExtensionTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
atmfAtmServiceTypeExtensionTable_get_first_data_point(void
                                                      **my_loop_context,
                                                      void
                                                      **my_data_context,
                                                      netsnmp_variable_list
                                                      * put_index_data,
                                                      netsnmp_iterator_info
                                                      *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFATMSERVICETYPEEXTENSIONTABLE *pData;
    int totalServiceTypeCount;

    /* assuming one service per ATM VC connection */
    totalServiceTypeCount = atmForumMibHelper_getServiceTypeCount();
    if (totalServiceTypeCount > 0) {
      pData = calloc( totalServiceTypeCount, sizeof(ATM_FORUM_MIB_ATMFATMSERVICETYPETABLE));
      if (pData == NULL)
        return NULL;
    }
    else
      return NULL;

    atmForumMibHelper_fillatmfAtmServiceTypeExtensionTable(pData);
    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) (&pData->index),
                       sizeof(pData->index));

    return put_index_data;
}

/** functionally the same as atmfAtmServiceTypeExtensionTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
atmfAtmServiceTypeExtensionTable_get_next_data_point(void
                                                     **my_loop_context,
                                                     void
                                                     **my_data_context,
                                                     netsnmp_variable_list
                                                     * put_index_data,
                                                     netsnmp_iterator_info
                                                     *mydata)
{
    netsnmp_variable_list *vptr;
    ATM_FORUM_MIB_ATMFATMSERVICETYPEEXTENSIONTABLE *pData;

    pData =
        (ATM_FORUM_MIB_ATMFATMSERVICETYPEEXTENSIONTABLE *) *
        my_loop_context;
    pData = pData->next;

    if (pData == NULL)
        return NULL;

    *my_loop_context = pData;
    *my_data_context = pData;

    vptr = put_index_data;
    snmp_set_var_value(vptr,
                       (u_char *) (&pData->index),
                       sizeof(pData->index));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the atmfAtmServiceTypeExtensionTable table, if anything else needs to be done */
int
atmfAtmServiceTypeExtensionTable_handler(netsnmp_mib_handler *handler,
                                         netsnmp_handler_registration
                                         *reginfo,
                                         netsnmp_agent_request_info
                                         *reqinfo,
                                         netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    ATM_FORUM_MIB_ATMFATMSERVICETYPEEXTENSIONTABLE *pData;

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the atmfAtmServiceTypeExtensionTable table in question 
         */
        pData =
            (ATM_FORUM_MIB_ATMFATMSERVICETYPEEXTENSIONTABLE *)
            netsnmp_extract_iterator_context(request);
        if (pData == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ATMFATMSERVICELAYER2PROTOCOLID:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)pData->atmfAtmServiceLayer2ProtocolId,
                                         pData->atmfAtmServiceLayer2ProtocolId_len);
                break;

            case COLUMN_ATMFATMSERVICELAYER3PROTOCOLID:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)pData->atmfAtmServiceLayer3ProtocolId,
                                         pData->atmfAtmServiceLayer3ProtocolId_len);
                break;
            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in atmfAtmServiceTypeExtensionTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in atmfAtmServiceTypeExtensionTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ATMFATMSERVICETYPEEXTENSIONTABLE */

int
get_atmfMySystemIdentifier(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                 (u_char *)("BrcmModem"),
                                 strlen("BrcmModem"));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

void
init_atmfMySystemIdentifier(void)
{
    static oid      atmfMySystemIdentifier_oid[] =
        { 1, 3, 6, 1, 4, 1, 353, 2, 1, 4, 0 };

    DEBUGMSGTL(("atmfMySystemIdentifier", "Initializing\n"));

    netsnmp_register_read_only_instance(netsnmp_create_handler_registration
                                        ("atmfMySystemIdentifier",
                                         get_atmfMySystemIdentifier,
                                         atmfMySystemIdentifier_oid,
                                         OID_LENGTH
                                         (atmfMySystemIdentifier_oid),
                                         HANDLER_CAN_RONLY));
}

#else                           /* SNMP_ATMFORUM_MIB != defined */
void
init_atmForum(void)
{
    return;
}
#endif                          /* #ifdef SNMP_ATMFORUM_MIB */
