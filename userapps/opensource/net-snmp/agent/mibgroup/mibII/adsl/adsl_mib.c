#ifdef SNMP_ADSL_MIB
/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.iterate.conf,v 5.5 2002/12/16 22:50:18 hardaker Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "adsl_mib.h"
#include "adslMibHelper.h"
#include <AdslMibDef.h>

#ifdef DO_ADSLATURPHYSTABLE
/** free context of adslAturPhysTable table */
void
adslAturPhysTable_contextFree(void *context,
                              netsnmp_iterator_info *dont_care)
{
    ADSLMIB_DEBUG(("\nadslAturPhysTable_contextFree()\n"));

    free(((pADSL_MIB_ADSLATURPHYSTABLE) context)->pTableBeginning);
}

/** Initialize the adslAturPhysTable table by defining its contents and how it's structured */
void
initialize_table_adslAturPhysTable(void)
{
    static oid      adslAturPhysTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 3 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    ADSLMIB_DEBUG(("\ninitialize_table_adslAturPhysTable()\n"));

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("adslAturPhysTable",
                                                     adslAturPhysTable_handler,
                                                     adslAturPhysTable_oid,
                                                     OID_LENGTH
                                                     (adslAturPhysTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 8;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = (Netsnmp_First_Data_Point *)
        adslAturPhysTable_get_first_data_point;
    iinfo->get_next_data_point = (Netsnmp_Next_Data_Point *)
        adslAturPhysTable_get_next_data_point;
    iinfo->free_loop_context_at_end = adslAturPhysTable_contextFree;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_adslAturPhysTable",
                "Registering table adslAturPhysTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** returns the first data point within the adslAturPhysTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
adslAturPhysTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATURPHYSTABLE pAdslMib_adslAturPhysTable;
    int             ifCount;

    ifCount = adslMibHelper_getIfCount();
    pAdslMib_adslAturPhysTable =
        calloc(ifCount, sizeof(ADSL_MIB_ADSLATURPHYSTABLE));

    if (pAdslMib_adslAturPhysTable == NULL) {
        printf("CANNOT ALLOCATE MEMORY: file %s, line %u \n", __FILE__,
               __LINE__);
        return (NULL);
    }

    adslMibHelper_filladslAturPhysTable(pAdslMib_adslAturPhysTable);
    *my_loop_context =
        (pADSL_MIB_ADSLATURPHYSTABLE) pAdslMib_adslAturPhysTable;
    *my_data_context =
        (pADSL_MIB_ADSLATURPHYSTABLE) pAdslMib_adslAturPhysTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAturPhysTable->ifIndex,
                       sizeof(pAdslMib_adslAturPhysTable->ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as adslAturPhysTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
adslAturPhysTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATURPHYSTABLE pAdslMib_adslAturPhysTable;

    ADSLMIB_DEBUG(("adslAturPhysTable_get_next_data_point"));

    pAdslMib_adslAturPhysTable =
        (pADSL_MIB_ADSLATURPHYSTABLE) * my_loop_context;
    pAdslMib_adslAturPhysTable = pAdslMib_adslAturPhysTable->next;

    if (pAdslMib_adslAturPhysTable == NULL)
        return (NULL);

    *my_loop_context =
        (pADSL_MIB_ADSLATURPHYSTABLE) pAdslMib_adslAturPhysTable;
    *my_data_context =
        (pADSL_MIB_ADSLATURPHYSTABLE) pAdslMib_adslAturPhysTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAturPhysTable->ifIndex,
                       sizeof(pAdslMib_adslAturPhysTable->ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the adslAturPhysTable table, if anything else needs to be done */
int
adslAturPhysTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    pADSL_MIB_ADSLATURPHYSTABLE pAdslMib_adslAturPhysTable;

    ADSLMIB_DEBUG(("Entered adslAturPhysTable_handler"));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the adslAturPhysTable table in question 
         */
        pAdslMib_adslAturPhysTable =
            (pADSL_MIB_ADSLATURPHYSTABLE)
            netsnmp_extract_iterator_context(request);

        if (pAdslMib_adslAturPhysTable == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ADSLATURINVSERIALNUMBER:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)
                                         pAdslMib_adslAturPhysTable->adslAturInvSerialNumber,
                                         sizeof
                                         (pAdslMib_adslAturPhysTable->adslAturInvSerialNumber));
                break;

            case COLUMN_ADSLATURINVVENDORID:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)
                                         pAdslMib_adslAturPhysTable->adslAturInvVendorID,
                                         strlen
                                         (pAdslMib_adslAturPhysTable->adslAturInvVendorID));
                break;

            case COLUMN_ADSLATURINVVERSIONNUMBER:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)
                                         pAdslMib_adslAturPhysTable->adslAturInvVersionNumber,
                                         strlen
                                         (pAdslMib_adslAturPhysTable->adslAturInvVersionNumber));
                break;

            case COLUMN_ADSLATURCURRSNRMGN:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAturPhysTable->adslAturCurrSnrMgn,
                                         sizeof
                                         (pAdslMib_adslAturPhysTable->adslAturCurrSnrMgn));
                break;

            case COLUMN_ADSLATURCURRATN:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *)&
                                         pAdslMib_adslAturPhysTable->adslAturCurrAtn,
                                         sizeof
                                         (pAdslMib_adslAturPhysTable->adslAturCurrAtn));
                break;

            case COLUMN_ADSLATURCURRSTATUS:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) &
                                         pAdslMib_adslAturPhysTable->adslAturCurrStatus,
                                         sizeof
                                         (pAdslMib_adslAturPhysTable->adslAturCurrStatus));
                break;

            case COLUMN_ADSLATURCURROUTPUTPWR:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAturPhysTable->adslAturCurrOutputPwr,
                                         sizeof
                                         (pAdslMib_adslAturPhysTable->adslAturCurrOutputPwr));
                break;

            case COLUMN_ADSLATURCURRATTAINABLERATE:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturPhysTable->adslAturCurrAttainableRate,
                                         sizeof
                                         (pAdslMib_adslAturPhysTable->adslAturCurrAttainableRate));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in adslAturPhysTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in adslAturPhysTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ADSLATURPHYSTABLE */
#ifdef DO_ADSLLINECONFPROFILETABLE
/** free context of adslLineConfProfileTable table */
void
adslLineConfProfileTable_contextFree(void *context,
                                     netsnmp_iterator_info *dont_care)
{
    ADSLMIB_DEBUG(("\nadslLineConfProfileTable_contextFree()\n"));

    free(((pADSL_MIB_ADSLLINECONFPROFILETABLE) context)->pTableBeginning);
}

/** Initialize the adslLineConfProfileTable table by defining its contents and how it's structured */
void
initialize_table_adslLineConfProfileTable(void)
{
    static oid      adslLineConfProfileTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 14 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    ADSLMIB_DEBUG(("\ninitialize_table_adslLineConfProfileTable()\n"));

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("adslLineConfProfileTable",
                                            adslLineConfProfileTable_handler,
                                            adslLineConfProfileTable_oid,
                                            OID_LENGTH
                                            (adslLineConfProfileTable_oid),
                                            HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_OCTET_STR, /* index: adslLineConfProfileName */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 30;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = (Netsnmp_First_Data_Point *)
        adslLineConfProfileTable_get_first_data_point;
    iinfo->get_next_data_point = (Netsnmp_Next_Data_Point *)
        adslLineConfProfileTable_get_next_data_point;
    iinfo->free_loop_context_at_end = adslLineConfProfileTable_contextFree;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_adslLineConfProfileTable",
                "Registering table adslLineConfProfileTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** returns the first data point within the adslLineConfProfileTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
adslLineConfProfileTable_get_first_data_point(void **my_loop_context,
                                              void **my_data_context,
                                              netsnmp_variable_list *
                                              put_index_data,
                                              netsnmp_iterator_info
                                              *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLLINECONFPROFILETABLE pAdslMib_adslLineConfProfileTable;
    int             ifCount;

    ifCount = adslMibHelper_getIfCount();
    pAdslMib_adslLineConfProfileTable =
        calloc(ifCount, sizeof(ADSL_MIB_ADSLLINECONFPROFILETABLE));

    if (pAdslMib_adslLineConfProfileTable == NULL) {
        printf("CANNOT ALLOCATE MEMORY: file %s, line %u \n", __FILE__,
               __LINE__);
        return (NULL);
    }

    adslMibHelper_filladslLineConfProfileTable
        (pAdslMib_adslLineConfProfileTable);
    *my_loop_context =
        (pADSL_MIB_ADSLLINECONFPROFILETABLE)
        pAdslMib_adslLineConfProfileTable;
    *my_data_context =
        (pADSL_MIB_ADSLLINECONFPROFILETABLE)
        pAdslMib_adslLineConfProfileTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslLineConfProfileTable->
                       ifIndex,
                       sizeof(pAdslMib_adslLineConfProfileTable->ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as adslLineConfProfileTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
adslLineConfProfileTable_get_next_data_point(void **my_loop_context,
                                             void **my_data_context,
                                             netsnmp_variable_list *
                                             put_index_data,
                                             netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLLINECONFPROFILETABLE pAdslMib_adslLineConfProfileTable;

    ADSLMIB_DEBUG(("adslLineConfProfileTable_get_next_data_point"));

    pAdslMib_adslLineConfProfileTable =
        (pADSL_MIB_ADSLLINECONFPROFILETABLE) * my_loop_context;
    pAdslMib_adslLineConfProfileTable =
        pAdslMib_adslLineConfProfileTable->next;

    if (pAdslMib_adslLineConfProfileTable == NULL)
        return (NULL);

    *my_loop_context =
        (pADSL_MIB_ADSLLINECONFPROFILETABLE)
        pAdslMib_adslLineConfProfileTable;
    *my_data_context =
        (pADSL_MIB_ADSLLINECONFPROFILETABLE)
        pAdslMib_adslLineConfProfileTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslLineConfProfileTable->
                       ifIndex,
                       sizeof(pAdslMib_adslLineConfProfileTable->ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the adslLineConfProfileTable table, if anything else needs to be done */
int
adslLineConfProfileTable_handler(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    pADSL_MIB_ADSLLINECONFPROFILETABLE pAdslMib_adslLineConfProfileTable;

    ADSLMIB_DEBUG(("Entered adslLineConfProfileTable_handler"));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the adslLineConfProfileTable table in question 
         */
        pAdslMib_adslLineConfProfileTable =
            (pADSL_MIB_ADSLLINECONFPROFILETABLE)
            netsnmp_extract_iterator_context(request);

        if (pAdslMib_adslLineConfProfileTable == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ADSLATUCCONFRATEMODE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATUCCONFRATECHANRATIO:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATUCCONFTARGETSNRMGN:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATUCCONFMAXSNRMGN:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATUCCONFMINSNRMGN:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATUCCONFDOWNSHIFTSNRMGN:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATUCCONFUPSHIFTSNRMGN:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATUCCONFMINUPSHIFTTIME:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATUCCONFMINDOWNSHIFTTIME:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATUCCHANCONFFASTMINTXRATE:
                snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATUCCHANCONFINTERLEAVEMINTXRATE:
                snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATUCCHANCONFFASTMAXTXRATE:
                snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATUCCHANCONFINTERLEAVEMAXTXRATE:
                snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATUCCHANCONFMAXINTERLEAVEDELAY:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATURCONFRATEMODE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATURCONFRATECHANRATIO:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATURCONFTARGETSNRMGN:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATURCONFMAXSNRMGN:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATURCONFMINSNRMGN:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATURCONFDOWNSHIFTSNRMGN:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATURCONFUPSHIFTSNRMGN:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATURCONFMINUPSHIFTTIME:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATURCONFMINDOWNSHIFTTIME:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATURCHANCONFFASTMINTXRATE:
                snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATURCHANCONFINTERLEAVEMINTXRATE:
                snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATURCHANCONFFASTMAXTXRATE:
                snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATURCHANCONFINTERLEAVEMAXTXRATE:
                snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLATURCHANCONFMAXINTERLEAVEDELAY:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            case COLUMN_ADSLLINECONFPROFILEROWSTATUS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineConfProfileTable->,
                                         sizeof
                                         (pAdslMib_adslLineConfProfileTable->));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in adslLineConfProfileTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in adslLineConfProfileTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ADSLLINECONFPROFILETABLE */
#ifdef DO_ADSLATURCHANTABLE
/** free context of adslAturChanTable table */
void
adslAturChanTable_contextFree(void *context,
                              netsnmp_iterator_info *dont_care)
{
    ADSLMIB_DEBUG(("\nadslAturChanTable_contextFree()\n"));

    free(((pADSL_MIB_ADSLATURCHANTABLE) context)->pTableBeginning);
}

/** Initialize the adslAturChanTable table by defining its contents and how it's structured */
void
initialize_table_adslAturChanTable(void)
{
    static oid      adslAturChanTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 5 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    ADSLMIB_DEBUG(("\ninitialize_table_adslAturChanTable()\n"));

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("adslAturChanTable",
                                                     adslAturChanTable_handler,
                                                     adslAturChanTable_oid,
                                                     OID_LENGTH
                                                     (adslAturChanTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 4;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = (Netsnmp_First_Data_Point *)
        adslAturChanTable_get_first_data_point;
    iinfo->get_next_data_point = (Netsnmp_Next_Data_Point *)
        adslAturChanTable_get_next_data_point;
    iinfo->free_loop_context_at_end = adslAturChanTable_contextFree;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_adslAturChanTable",
                "Registering table adslAturChanTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** returns the first data point within the adslAturChanTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
adslAturChanTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATURCHANTABLE pAdslMib_adslAturChanTable;
    int             ifCount;

    ifCount = adslMibHelper_getIfCount();
    pAdslMib_adslAturChanTable =
        calloc(ifCount, sizeof(ADSL_MIB_ADSLATURCHANTABLE));

    if (pAdslMib_adslAturChanTable == NULL) {
        printf("CANNOT ALLOCATE MEMORY: file %s, line %u \n", __FILE__,
               __LINE__);
        return (NULL);
    }

    adslMibHelper_filladslAturChanTable(pAdslMib_adslAturChanTable);
    *my_loop_context =
        (pADSL_MIB_ADSLATURCHANTABLE) pAdslMib_adslAturChanTable;
    *my_data_context =
        (pADSL_MIB_ADSLATURCHANTABLE) pAdslMib_adslAturChanTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAturChanTable->ifIndex,
                       sizeof(pAdslMib_adslAturChanTable->ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as adslAturChanTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
adslAturChanTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATURCHANTABLE pAdslMib_adslAturChanTable;

    ADSLMIB_DEBUG(("adslAturChanTable_get_next_data_point"));

    pAdslMib_adslAturChanTable =
        (pADSL_MIB_ADSLATURCHANTABLE) * my_loop_context;
    pAdslMib_adslAturChanTable = pAdslMib_adslAturChanTable->next;

    if (pAdslMib_adslAturChanTable == NULL)
        return (NULL);

    *my_loop_context =
        (pADSL_MIB_ADSLATURCHANTABLE) pAdslMib_adslAturChanTable;
    *my_data_context =
        (pADSL_MIB_ADSLATURCHANTABLE) pAdslMib_adslAturChanTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAturChanTable->ifIndex,
                       sizeof(pAdslMib_adslAturChanTable->ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the adslAturChanTable table, if anything else needs to be done */
int
adslAturChanTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    pADSL_MIB_ADSLATURCHANTABLE pAdslMib_adslAturChanTable;

    ADSLMIB_DEBUG(("Entered adslAturChanTable_handler"));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the adslAturChanTable table in question 
         */
        pAdslMib_adslAturChanTable =
            (pADSL_MIB_ADSLATURCHANTABLE)
            netsnmp_extract_iterator_context(request);

        if (pAdslMib_adslAturChanTable == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ADSLATURCHANINTERLEAVEDELAY:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanTable->adslAturChanInterleaveDelay,
                                         sizeof
                                         (pAdslMib_adslAturChanTable->adslAturChanInterleaveDelay));
                break;

            case COLUMN_ADSLATURCHANCURRTXRATE:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanTable->adslAturChanCurrTxRate,
                                         sizeof
                                         (pAdslMib_adslAturChanTable->adslAturChanCurrTxRate));
                break;

            case COLUMN_ADSLATURCHANPREVTXRATE:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanTable->adslAturChanPrevTxRate,
                                         sizeof
                                         (pAdslMib_adslAturChanTable->adslAturChanPrevTxRate));
                break;

            case COLUMN_ADSLATURCHANCRCBLOCKLENGTH:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanTable->adslAturChanCrcBlockLength,
                                         sizeof
                                         (pAdslMib_adslAturChanTable->adslAturChanCrcBlockLength));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in adslAturChanTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in adslAturChanTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ADSLATURCHANTABLE */
#ifdef DO_ADSLATUCPERFDATATABLE
/** free context of adslAtucPerfDataTable table */
void
adslAtucPerfDataTable_contextFree(void *context,
                                  netsnmp_iterator_info *dont_care)
{
    ADSLMIB_DEBUG(("\nadslAtucPerfDataTable_contextFree()\n"));

    free(((pADSL_MIB_ADSLATUCPERFDATATABLE) context)->pTableBeginning);
}

/** Initialize the adslAtucPerfDataTable table by defining its contents and how it's structured */
void
initialize_table_adslAtucPerfDataTable(void)
{
    static oid      adslAtucPerfDataTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 6 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    ADSLMIB_DEBUG(("\ninitialize_table_adslAtucPerfDataTable()\n"));

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("adslAtucPerfDataTable",
                                            adslAtucPerfDataTable_handler,
                                            adslAtucPerfDataTable_oid,
                                            OID_LENGTH
                                            (adslAtucPerfDataTable_oid),
                                            HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 29;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = (Netsnmp_First_Data_Point *)
        adslAtucPerfDataTable_get_first_data_point;
    iinfo->get_next_data_point = (Netsnmp_Next_Data_Point *)
        adslAtucPerfDataTable_get_next_data_point;
    iinfo->free_loop_context_at_end = adslAtucPerfDataTable_contextFree;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_adslAtucPerfDataTable",
                "Registering table adslAtucPerfDataTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** returns the first data point within the adslAtucPerfDataTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
adslAtucPerfDataTable_get_first_data_point(void **my_loop_context,
                                           void **my_data_context,
                                           netsnmp_variable_list *
                                           put_index_data,
                                           netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATUCPERFDATATABLE pAdslMib_adslAtucPerfDataTable;
    int             ifCount;

    ifCount = adslMibHelper_getIfCount();
    pAdslMib_adslAtucPerfDataTable =
        calloc(ifCount, sizeof(ADSL_MIB_ADSLATUCPERFDATATABLE));

    if (pAdslMib_adslAtucPerfDataTable == NULL) {
        printf("CANNOT ALLOCATE MEMORY: file %s, line %u \n", __FILE__,
               __LINE__);
        return (NULL);
    }

    adslMibHelper_filladslAtucPerfDataTable
        (pAdslMib_adslAtucPerfDataTable);
    *my_loop_context =
        (pADSL_MIB_ADSLATUCPERFDATATABLE) pAdslMib_adslAtucPerfDataTable;
    *my_data_context =
        (pADSL_MIB_ADSLATUCPERFDATATABLE) pAdslMib_adslAtucPerfDataTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAtucPerfDataTable->
                       ifIndex,
                       sizeof(pAdslMib_adslAtucPerfDataTable->ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as adslAtucPerfDataTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
adslAtucPerfDataTable_get_next_data_point(void **my_loop_context,
                                          void **my_data_context,
                                          netsnmp_variable_list *
                                          put_index_data,
                                          netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATUCPERFDATATABLE pAdslMib_adslAtucPerfDataTable;

    ADSLMIB_DEBUG(("adslAtucPerfDataTable_get_next_data_point"));

    pAdslMib_adslAtucPerfDataTable =
        (pADSL_MIB_ADSLATUCPERFDATATABLE) * my_loop_context;
    pAdslMib_adslAtucPerfDataTable = pAdslMib_adslAtucPerfDataTable->next;

    if (pAdslMib_adslAtucPerfDataTable == NULL)
        return (NULL);

    *my_loop_context =
        (pADSL_MIB_ADSLATUCPERFDATATABLE) pAdslMib_adslAtucPerfDataTable;
    *my_data_context =
        (pADSL_MIB_ADSLATUCPERFDATATABLE) pAdslMib_adslAtucPerfDataTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAtucPerfDataTable->
                       ifIndex,
                       sizeof(pAdslMib_adslAtucPerfDataTable->ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the adslAtucPerfDataTable table, if anything else needs to be done */
int
adslAtucPerfDataTable_handler(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    pADSL_MIB_ADSLATUCPERFDATATABLE pAdslMib_adslAtucPerfDataTable;

    ADSLMIB_DEBUG(("Entered adslAtucPerfDataTable_handler"));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the adslAtucPerfDataTable table in question 
         */
        pAdslMib_adslAtucPerfDataTable =
            (pADSL_MIB_ADSLATUCPERFDATATABLE)
            netsnmp_extract_iterator_context(request);

        if (pAdslMib_adslAtucPerfDataTable == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ADSLATUCPERFLOFS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfLofs,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfLofs));
                break;

            case COLUMN_ADSLATUCPERFLOSS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfLoss,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfLoss));
                break;

            case COLUMN_ADSLATUCPERFLOLS:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,
					 (u_char*)NULL,0);
		break;
            case COLUMN_ADSLATUCPERFLPRS:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,
					 (u_char*)NULL,0);
                break;

            case COLUMN_ADSLATUCPERFESS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfESs,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfESs));
                break;

            case COLUMN_ADSLATUCPERFINITS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfInits,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfInits));
                break;

            case COLUMN_ADSLATUCPERFVALIDINTERVALS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfValidIntervals,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfValidIntervals));
                break;

            case COLUMN_ADSLATUCPERFINVALIDINTERVALS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfInvalidIntervals,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfInvalidIntervals));
                break;

            case COLUMN_ADSLATUCPERFCURR15MINTIMEELAPSED:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr15MinTimeElapsed,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr15MinTimeElapsed));
                break;

            case COLUMN_ADSLATUCPERFCURR15MINLOFS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr15MinLofs,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr15MinLofs));
                break;

            case COLUMN_ADSLATUCPERFCURR15MINLOSS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr15MinLoss,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr15MinLoss));
                break;

            case COLUMN_ADSLATUCPERFCURR15MINLOLS:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,
					 (u_char*)NULL,0);
                break;

            case COLUMN_ADSLATUCPERFCURR15MINLPRS:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,
					 (u_char*)NULL,0);
                break;

            case COLUMN_ADSLATUCPERFCURR15MINESS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr15MinESs,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr15MinESs));
                break;

            case COLUMN_ADSLATUCPERFCURR15MININITS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr15MinInits,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr15MinInits));
                break;

            case COLUMN_ADSLATUCPERFCURR1DAYTIMEELAPSED:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr1DayTimeElapsed,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr1DayTimeElapsed));
                break;

            case COLUMN_ADSLATUCPERFCURR1DAYLOFS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr1DayLofs,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr1DayLofs));
                break;

            case COLUMN_ADSLATUCPERFCURR1DAYLOSS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr1DayLoss,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr1DayLoss));
                break;

            case COLUMN_ADSLATUCPERFCURR1DAYLOLS:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,
					 (u_char*)NULL,0);
                break;

            case COLUMN_ADSLATUCPERFCURR1DAYLPRS:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,
					 (u_char*)NULL,0);
                break;

            case COLUMN_ADSLATUCPERFCURR1DAYESS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr15MinESs,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr15MinESs));
                break;

            case COLUMN_ADSLATUCPERFCURR1DAYINITS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr1DayInits,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfCurr1DayInits));
                break;

            case COLUMN_ADSLATUCPERFPREV1DAYMONISECS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfPrev1DayMoniSecs,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfPrev1DayMoniSecs));
                break;

            case COLUMN_ADSLATUCPERFPREV1DAYLOFS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfPrev1DayLofs,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfPrev1DayLofs));
                break;

            case COLUMN_ADSLATUCPERFPREV1DAYLOSS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfPrev1DayLoss,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfPrev1DayLoss));
                break;

            case COLUMN_ADSLATUCPERFPREV1DAYLOLS:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,
					 (u_char*)NULL,0);
                break;

            case COLUMN_ADSLATUCPERFPREV1DAYLPRS:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,
					 (u_char*)NULL,0);
                break;

            case COLUMN_ADSLATUCPERFPREV1DAYESS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfPrev1DayESs,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfPrev1DayESs));
                break;

            case COLUMN_ADSLATUCPERFPREV1DAYINITS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucPerfDataTable->adslAtucPerfPrev1DayInits,
                                         sizeof
                                         (pAdslMib_adslAtucPerfDataTable->adslAtucPerfPrev1DayInits));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in adslAtucPerfDataTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in adslAtucPerfDataTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ADSLATUCPERFDATATABLE */
#ifdef DO_ADSLATUCINTERVALTABLE
/** free context of adslAtucIntervalTable table */
void
adslAtucIntervalTable_contextFree(void *context,
                                  netsnmp_iterator_info *dont_care)
{
    ADSLMIB_DEBUG(("\nadslAtucIntervalTable_contextFree()\n"));

    free(((pADSL_MIB_ADSLATUCINTERVALTABLE) context)->pTableBeginning);
}

/** Initialize the adslAtucIntervalTable table by defining its contents and how it's structured */
void
initialize_table_adslAtucIntervalTable(void)
{
    static oid      adslAtucIntervalTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 8 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    ADSLMIB_DEBUG(("\ninitialize_table_adslAtucIntervalTable()\n"));

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("adslAtucIntervalTable",
                                            adslAtucIntervalTable_handler,
                                            adslAtucIntervalTable_oid,
                                            OID_LENGTH
                                            (adslAtucIntervalTable_oid),
                                            HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     ASN_INTEGER,       /* index: adslAtucIntervalNumber */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 8;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = (Netsnmp_First_Data_Point *)
        adslAtucIntervalTable_get_first_data_point;
    iinfo->get_next_data_point = (Netsnmp_Next_Data_Point *)
        adslAtucIntervalTable_get_next_data_point;
    iinfo->free_loop_context_at_end = adslAtucIntervalTable_contextFree;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_adslAtucIntervalTable",
                "Registering table adslAtucIntervalTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** returns the first data point within the adslAtucIntervalTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
adslAtucIntervalTable_get_first_data_point(void **my_loop_context,
                                           void **my_data_context,
                                           netsnmp_variable_list *
                                           put_index_data,
                                           netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATUCINTERVALTABLE pAdslMib_adslAtucIntervalTable;
    int             ifCount;

    ifCount = adslMibHelper_getIfCount();
    pAdslMib_adslAtucIntervalTable =
        calloc(ifCount, sizeof(ADSL_MIB_ADSLATUCINTERVALTABLE));

    if (pAdslMib_adslAtucIntervalTable == NULL) {
        printf("CANNOT ALLOCATE MEMORY: file %s, line %u \n", __FILE__,
               __LINE__);
        return (NULL);
    }

    adslMibHelper_filladslAtucIntervalTable
        (pAdslMib_adslAtucIntervalTable);
    *my_loop_context =
        (pADSL_MIB_ADSLATUCINTERVALTABLE) pAdslMib_adslAtucIntervalTable;
    *my_data_context =
        (pADSL_MIB_ADSLATUCINTERVALTABLE) pAdslMib_adslAtucIntervalTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAtucIntervalTable->
                       ifIndex,
                       sizeof(pAdslMib_adslAtucIntervalTable->ifIndex));
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAtucIntervalTable->
                       adslAtucIntervalNumber,
                       sizeof(pAdslMib_adslAtucIntervalTable->adslAtucIntervalNumber));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as adslAtucIntervalTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
adslAtucIntervalTable_get_next_data_point(void **my_loop_context,
                                          void **my_data_context,
                                          netsnmp_variable_list *
                                          put_index_data,
                                          netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATUCINTERVALTABLE pAdslMib_adslAtucIntervalTable;

    ADSLMIB_DEBUG(("adslAtucIntervalTable_get_next_data_point"));

    pAdslMib_adslAtucIntervalTable =
        (pADSL_MIB_ADSLATUCINTERVALTABLE) * my_loop_context;
    pAdslMib_adslAtucIntervalTable = pAdslMib_adslAtucIntervalTable->next;

    if (pAdslMib_adslAtucIntervalTable == NULL)
        return (NULL);

    *my_loop_context =
        (pADSL_MIB_ADSLATUCINTERVALTABLE) pAdslMib_adslAtucIntervalTable;
    *my_data_context =
        (pADSL_MIB_ADSLATUCINTERVALTABLE) pAdslMib_adslAtucIntervalTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAtucIntervalTable->
                       ifIndex,
                       sizeof(pAdslMib_adslAtucIntervalTable->ifIndex));
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAtucIntervalTable->
                       adslAtucIntervalNumber,
                       sizeof(pAdslMib_adslAtucIntervalTable->adslAtucIntervalNumber));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the adslAtucIntervalTable table, if anything else needs to be done */
int
adslAtucIntervalTable_handler(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    pADSL_MIB_ADSLATUCINTERVALTABLE pAdslMib_adslAtucIntervalTable;

    ADSLMIB_DEBUG(("Entered adslAtucIntervalTable_handler"));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the adslAtucIntervalTable table in question 
         */
        pAdslMib_adslAtucIntervalTable =
            (pADSL_MIB_ADSLATUCINTERVALTABLE)
            netsnmp_extract_iterator_context(request);

        if (pAdslMib_adslAtucIntervalTable == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ADSLATUCINTERVALLOFS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucIntervalTable->adslAtucIntervalLofs,
                                         sizeof
                                         (pAdslMib_adslAtucIntervalTable->adslAtucIntervalLofs));
                break;

            case COLUMN_ADSLATUCINTERVALLOSS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucIntervalTable->adslAtucIntervalLoss,
                                         sizeof
                                         (pAdslMib_adslAtucIntervalTable->adslAtucIntervalLoss));
                break;

            case COLUMN_ADSLATUCINTERVALLOLS:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,
					 (u_char*)NULL,0);
                break;

            case COLUMN_ADSLATUCINTERVALLPRS:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,
					 (u_char*)NULL,0);
                break;

            case COLUMN_ADSLATUCINTERVALESS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucIntervalTable->adslAtucIntervalESs,
                                         sizeof
                                         (pAdslMib_adslAtucIntervalTable->adslAtucIntervalESs));
                break;

            case COLUMN_ADSLATUCINTERVALINITS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucIntervalTable->adslAtucIntervalInits,
                                         sizeof
                                         (pAdslMib_adslAtucIntervalTable->adslAtucIntervalInits));
                break;

            case COLUMN_ADSLATUCINTERVALVALIDDATA:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAtucIntervalTable->adslAtucIntervalValidData,
                                         sizeof
                                         (pAdslMib_adslAtucIntervalTable->adslAtucIntervalValidData));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in adslAtucIntervalTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in adslAtucIntervalTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ADSLATUCINTERVALTABLE */
#ifdef DO_ADSLATURPERFDATATABLE
/** free context of adslAturPerfDataTable table */
void
adslAturPerfDataTable_contextFree(void *context,
                                  netsnmp_iterator_info *dont_care)
{
    ADSLMIB_DEBUG(("\nadslAturPerfDataTable_contextFree()\n"));

    free(((pADSL_MIB_ADSLATURPERFDATATABLE) context)->pTableBeginning);
}

/** Initialize the adslAturPerfDataTable table by defining its contents and how it's structured */
void
initialize_table_adslAturPerfDataTable(void)
{
    static oid      adslAturPerfDataTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 7 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    ADSLMIB_DEBUG(("\ninitialize_table_adslAturPerfDataTable()\n"));

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("adslAturPerfDataTable",
                                            adslAturPerfDataTable_handler,
                                            adslAturPerfDataTable_oid,
                                            OID_LENGTH
                                            (adslAturPerfDataTable_oid),
                                            HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 21;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = (Netsnmp_First_Data_Point *)
        adslAturPerfDataTable_get_first_data_point;
    iinfo->get_next_data_point = (Netsnmp_Next_Data_Point *)
        adslAturPerfDataTable_get_next_data_point;
    iinfo->free_loop_context_at_end = adslAturPerfDataTable_contextFree;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_adslAturPerfDataTable",
                "Registering table adslAturPerfDataTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** returns the first data point within the adslAturPerfDataTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
adslAturPerfDataTable_get_first_data_point(void **my_loop_context,
                                           void **my_data_context,
                                           netsnmp_variable_list *
                                           put_index_data,
                                           netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATURPERFDATATABLE pAdslMib_adslAturPerfDataTable;
    int             ifCount;

    ifCount = adslMibHelper_getIfCount();
    pAdslMib_adslAturPerfDataTable =
        calloc(ifCount, sizeof(ADSL_MIB_ADSLATURPERFDATATABLE));

    if (pAdslMib_adslAturPerfDataTable == NULL) {
        printf("CANNOT ALLOCATE MEMORY: file %s, line %u \n", __FILE__,
               __LINE__);
        return (NULL);
    }

    adslMibHelper_filladslAturPerfDataTable
        (pAdslMib_adslAturPerfDataTable);
    *my_loop_context =
        (pADSL_MIB_ADSLATURPERFDATATABLE) pAdslMib_adslAturPerfDataTable;
    *my_data_context =
        (pADSL_MIB_ADSLATURPERFDATATABLE) pAdslMib_adslAturPerfDataTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAturPerfDataTable->
                       ifIndex,
                       sizeof(pAdslMib_adslAturPerfDataTable->ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as adslAturPerfDataTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
adslAturPerfDataTable_get_next_data_point(void **my_loop_context,
                                          void **my_data_context,
                                          netsnmp_variable_list *
                                          put_index_data,
                                          netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATURPERFDATATABLE pAdslMib_adslAturPerfDataTable;

    ADSLMIB_DEBUG(("adslAturPerfDataTable_get_next_data_point"));

    pAdslMib_adslAturPerfDataTable =
        (pADSL_MIB_ADSLATURPERFDATATABLE) * my_loop_context;
    pAdslMib_adslAturPerfDataTable = pAdslMib_adslAturPerfDataTable->next;

    if (pAdslMib_adslAturPerfDataTable == NULL)
        return (NULL);

    *my_loop_context =
        (pADSL_MIB_ADSLATURPERFDATATABLE) pAdslMib_adslAturPerfDataTable;
    *my_data_context =
        (pADSL_MIB_ADSLATURPERFDATATABLE) pAdslMib_adslAturPerfDataTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAturPerfDataTable->
                       ifIndex,
                       sizeof(pAdslMib_adslAturPerfDataTable->ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the adslAturPerfDataTable table, if anything else needs to be done */
int
adslAturPerfDataTable_handler(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    pADSL_MIB_ADSLATURPERFDATATABLE pAdslMib_adslAturPerfDataTable;

    ADSLMIB_DEBUG(("Entered adslAturPerfDataTable_handler"));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the adslAturPerfDataTable table in question 
         */
        pAdslMib_adslAturPerfDataTable =
            (pADSL_MIB_ADSLATURPERFDATATABLE)
            netsnmp_extract_iterator_context(request);

        if (pAdslMib_adslAturPerfDataTable == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ADSLATURPERFLOFS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfLofs,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfLofs));
                break;

            case COLUMN_ADSLATURPERFLOSS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfLoss,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfLoss));
                break;

            case COLUMN_ADSLATURPERFLPRS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfLprs,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfLprs));
                break;

            case COLUMN_ADSLATURPERFESS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfESs,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfESs));
                break;

            case COLUMN_ADSLATURPERFVALIDINTERVALS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfValidIntervals,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfValidIntervals));
                break;

            case COLUMN_ADSLATURPERFINVALIDINTERVALS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfInvalidIntervals,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfInvalidIntervals));
                break;

            case COLUMN_ADSLATURPERFCURR15MINTIMEELAPSED:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfCurr15MinTimeElapsed,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfCurr15MinTimeElapsed));
                break;

            case COLUMN_ADSLATURPERFCURR15MINLOFS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfCurr15MinLofs,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfCurr15MinLofs));
                break;

            case COLUMN_ADSLATURPERFCURR15MINLOSS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfCurr15MinLoss,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfCurr15MinLoss));
                break;

            case COLUMN_ADSLATURPERFCURR15MINLPRS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfCurr15MinLprs,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfCurr15MinLprs));
                break;

            case COLUMN_ADSLATURPERFCURR15MINESS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfCurr15MinESs,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfCurr15MinESs));
                break;

            case COLUMN_ADSLATURPERFCURR1DAYTIMEELAPSED:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfCurr1DayTimeElapsed,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfCurr1DayTimeElapsed));
                break;

            case COLUMN_ADSLATURPERFCURR1DAYLOFS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfCurr1DayLofs,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfCurr1DayLofs));
                break;

            case COLUMN_ADSLATURPERFCURR1DAYLOSS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfCurr1DayLoss,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfCurr1DayLoss));
                break;

            case COLUMN_ADSLATURPERFCURR1DAYLPRS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfCurr1DayLprs,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfCurr1DayLprs));
                break;

            case COLUMN_ADSLATURPERFCURR1DAYESS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfCurr1DayESs,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfCurr1DayESs));
                break;

            case COLUMN_ADSLATURPERFPREV1DAYMONISECS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfPrev1DayMoniSecs,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfPrev1DayMoniSecs));
                break;

            case COLUMN_ADSLATURPERFPREV1DAYLOFS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfPrev1DayLofs,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfPrev1DayLofs));
                break;

            case COLUMN_ADSLATURPERFPREV1DAYLOSS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfPrev1DayLoss,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfPrev1DayLoss));
                break;

            case COLUMN_ADSLATURPERFPREV1DAYLPRS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfPrev1DayLprs,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfPrev1DayLprs));
                break;

            case COLUMN_ADSLATURPERFPREV1DAYESS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturPerfDataTable->adslAturPerfPrev1DayESs,
                                         sizeof
                                         (pAdslMib_adslAturPerfDataTable->adslAturPerfPrev1DayESs));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in adslAturPerfDataTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in adslAturPerfDataTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ADSLATURPERFDATATABLE */
#ifdef DO_ADSLLINEALARMCONFPROFILETABLE
/** free context of adslLineAlarmConfProfileTable table */
void
adslLineAlarmConfProfileTable_contextFree(void *context,
                                          netsnmp_iterator_info *dont_care)
{
    ADSLMIB_DEBUG(("\nadslLineAlarmConfProfileTable_contextFree()\n"));

    free(((pADSL_MIB_ADSLLINEALARMCONFPROFILETABLE) context)->
         pTableBeginning);
}

/** Initialize the adslLineAlarmConfProfileTable table by defining its contents and how it's structured */
void
initialize_table_adslLineAlarmConfProfileTable(void)
{
    static oid      adslLineAlarmConfProfileTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 15 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    ADSLMIB_DEBUG(("\ninitialize_table_adslLineAlarmConfProfileTable()\n"));

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration
        ("adslLineAlarmConfProfileTable",
         adslLineAlarmConfProfileTable_handler,
         adslLineAlarmConfProfileTable_oid,
         OID_LENGTH(adslLineAlarmConfProfileTable_oid),
         HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_OCTET_STR, /* index: adslLineAlarmConfProfileName */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 20;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = (Netsnmp_First_Data_Point *)
        adslLineAlarmConfProfileTable_get_first_data_point;
    iinfo->get_next_data_point = (Netsnmp_Next_Data_Point *)
        adslLineAlarmConfProfileTable_get_next_data_point;
    iinfo->free_loop_context_at_end =
        adslLineAlarmConfProfileTable_contextFree;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_adslLineAlarmConfProfileTable",
                "Registering table adslLineAlarmConfProfileTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** returns the first data point within the adslLineAlarmConfProfileTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
adslLineAlarmConfProfileTable_get_first_data_point(void **my_loop_context,
                                                   void **my_data_context,
                                                   netsnmp_variable_list *
                                                   put_index_data,
                                                   netsnmp_iterator_info
                                                   *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLLINEALARMCONFPROFILETABLE
        pAdslMib_adslLineAlarmConfProfileTable;
    int             ifCount;

    ifCount = adslMibHelper_getIfCount();
    pAdslMib_adslLineAlarmConfProfileTable =
        calloc(ifCount, sizeof(ADSL_MIB_ADSLLINEALARMCONFPROFILETABLE));

    if (pAdslMib_adslLineAlarmConfProfileTable == NULL) {
        printf("CANNOT ALLOCATE MEMORY: file %s, line %u \n", __FILE__,
               __LINE__);
        return (NULL);
    }
    adslMibHelper_filladslLineAlarmConfProfileTable
        (pAdslMib_adslLineAlarmConfProfileTable);
    *my_loop_context =
        (pADSL_MIB_ADSLLINEALARMCONFPROFILETABLE)
        pAdslMib_adslLineAlarmConfProfileTable;
    *my_data_context =
        (pADSL_MIB_ADSLLINEALARMCONFPROFILETABLE)
        pAdslMib_adslLineAlarmConfProfileTable;
    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) &
                       pAdslMib_adslLineAlarmConfProfileTable->ifIndex,
                       sizeof(pAdslMib_adslLineAlarmConfProfileTable->
                              ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as adslLineAlarmConfProfileTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
adslLineAlarmConfProfileTable_get_next_data_point(void **my_loop_context,
                                                  void **my_data_context,
                                                  netsnmp_variable_list *
                                                  put_index_data,
                                                  netsnmp_iterator_info
                                                  *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLLINEALARMCONFPROFILETABLE
        pAdslMib_adslLineAlarmConfProfileTable;

    ADSLMIB_DEBUG(("adslLineAlarmConfProfileTable_get_next_data_point"));

    pAdslMib_adslLineAlarmConfProfileTable =
        (pADSL_MIB_ADSLLINEALARMCONFPROFILETABLE) * my_loop_context;
    pAdslMib_adslLineAlarmConfProfileTable =
        pAdslMib_adslLineAlarmConfProfileTable->next;

    if (pAdslMib_adslLineAlarmConfProfileTable == NULL)
        return (NULL);

    *my_loop_context =
        (pADSL_MIB_ADSLLINEALARMCONFPROFILETABLE)
        pAdslMib_adslLineAlarmConfProfileTable;
    *my_data_context =
        (pADSL_MIB_ADSLLINEALARMCONFPROFILETABLE)
        pAdslMib_adslLineAlarmConfProfileTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) &
                       pAdslMib_adslLineAlarmConfProfileTable->ifIndex,
                       sizeof(pAdslMib_adslLineAlarmConfProfileTable->
                              ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the adslLineAlarmConfProfileTable table, if anything else needs to be done */
int
adslLineAlarmConfProfileTable_handler(netsnmp_mib_handler *handler,
                                      netsnmp_handler_registration
                                      *reginfo,
                                      netsnmp_agent_request_info *reqinfo,
                                      netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    pADSL_MIB_ADSLLINEALARMCONFPROFILETABLE
        pAdslMib_adslLineAlarmConfProfileTable;

    ADSLMIB_DEBUG(("Entered adslLineAlarmConfProfileTable_handler"));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the adslLineAlarmConfProfileTable table in question 
         */
        pAdslMib_adslLineAlarmConfProfileTable =
            (pADSL_MIB_ADSLLINEALARMCONFPROFILETABLE)
            netsnmp_extract_iterator_context(request);

        if (pAdslMib_adslLineAlarmConfProfileTable == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ADSLATUCTHRESH15MINLOFS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslAtucThresh15MinLofs,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslAtucThresh15MinLofs));
                break;

            case COLUMN_ADSLATUCTHRESH15MINLOSS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslAtucThresh15MinLoss,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslAtucThresh15MinLoss));
                break;

            case COLUMN_ADSLATUCTHRESH15MINLOLS:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,
					 (u_char*)NULL,0);
                break;

            case COLUMN_ADSLATUCTHRESH15MINLPRS:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,
					 (u_char*)NULL,0);
                break;

            case COLUMN_ADSLATUCTHRESH15MINESS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslAtucThresh15MinESs,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslAtucThresh15MinESs));
                break;

            case COLUMN_ADSLATUCTHRESHFASTRATEUP:
                snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslAtucThreshFastRateUp,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslAtucThreshFastRateUp));
                break;

            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEUP:
                snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslAtucThreshInterleaveRateUp,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslAtucThreshInterleaveRateUp));
                break;

            case COLUMN_ADSLATUCTHRESHFASTRATEDOWN:
                snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslAtucThreshFastRateDown,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslAtucThreshFastRateDown));
                break;

            case COLUMN_ADSLATUCTHRESHINTERLEAVERATEDOWN:
                snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslAtucThreshInterleaveRateDown,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslAtucThreshInterleaveRateDown));
                break;

            case COLUMN_ADSLATUCINITFAILURETRAPENABLE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslAtucInitFailureTrapEnable,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslAtucInitFailureTrapEnable));
                break;

            case COLUMN_ADSLATURTHRESH15MINLOFS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslAturThresh15MinLofs,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslAturThresh15MinLofs));
                break;

            case COLUMN_ADSLATURTHRESH15MINLOSS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslAturThresh15MinLoss,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslAturThresh15MinLoss));
                break;

            case COLUMN_ADSLATURTHRESH15MINLPRS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslAturThresh15MinLprs,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslAturThresh15MinLprs));
                break;

            case COLUMN_ADSLATURTHRESH15MINESS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslAturThresh15MinESs,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslAturThresh15MinESs));
                break;

            case COLUMN_ADSLATURTHRESHFASTRATEUP:
                snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslAturThreshFastRateUp,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslAturThreshFastRateUp));
                break;

            case COLUMN_ADSLATURTHRESHINTERLEAVERATEUP:
                snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslAturThreshInterleaveRateUp,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslAturThreshInterleaveRateUp));
                break;

            case COLUMN_ADSLATURTHRESHFASTRATEDOWN:
                snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslAturThreshFastRateDown,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslAturThreshFastRateDown));
                break;

            case COLUMN_ADSLATURTHRESHINTERLEAVERATEDOWN:
                snmp_set_var_typed_value(var, ASN_UNSIGNED,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslAturThreshInterleaveRateDown,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslAturThreshInterleaveRateDown));
                break;

            case COLUMN_ADSLLINEALARMCONFPROFILEROWSTATUS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineAlarmConfProfileTable->adslLineAlarmConfProfileRowStatus,
                                         sizeof
                                         (pAdslMib_adslLineAlarmConfProfileTable->adslLineAlarmConfProfileRowStatus));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in adslLineAlarmConfProfileTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in adslLineAlarmConfProfileTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ADSLLINEALARMCONFPROFILETABLE */
#ifdef DO_ADSLATURCHANPERFDATATABLE
/** free context of adslAturChanPerfDataTable table */
void
adslAturChanPerfDataTable_contextFree(void *context,
                                      netsnmp_iterator_info *dont_care)
{
    ADSLMIB_DEBUG(("\nadslAturChanPerfDataTable_contextFree()\n"));

    free(((pADSL_MIB_ADSLATURCHANPERFDATATABLE) context)->pTableBeginning);
}

/** Initialize the adslAturChanPerfDataTable table by defining its contents and how it's structured */
void
initialize_table_adslAturChanPerfDataTable(void)
{
    static oid      adslAturChanPerfDataTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 11 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    ADSLMIB_DEBUG(("\ninitialize_table_adslAturChanPerfDataTable()\n"));

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("adslAturChanPerfDataTable",
                                            adslAturChanPerfDataTable_handler,
                                            adslAturChanPerfDataTable_oid,
                                            OID_LENGTH
                                            (adslAturChanPerfDataTable_oid),
                                            HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 21;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = (Netsnmp_First_Data_Point *)
        adslAturChanPerfDataTable_get_first_data_point;
    iinfo->get_next_data_point = (Netsnmp_Next_Data_Point *)
        adslAturChanPerfDataTable_get_next_data_point;
    iinfo->free_loop_context_at_end =
        adslAturChanPerfDataTable_contextFree;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_adslAturChanPerfDataTable",
                "Registering table adslAturChanPerfDataTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** returns the first data point within the adslAturChanPerfDataTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
adslAturChanPerfDataTable_get_first_data_point(void **my_loop_context,
                                               void **my_data_context,
                                               netsnmp_variable_list *
                                               put_index_data,
                                               netsnmp_iterator_info
                                               *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATURCHANPERFDATATABLE pAdslMib_adslAturChanPerfDataTable;
    int             ifCount;

    ifCount = adslMibHelper_getIfCount();
    pAdslMib_adslAturChanPerfDataTable =
        calloc(ifCount, sizeof(ADSL_MIB_ADSLATURCHANPERFDATATABLE));

    if (pAdslMib_adslAturChanPerfDataTable == NULL) {
        printf("CANNOT ALLOCATE MEMORY: file %s, line %u \n", __FILE__,
               __LINE__);
        return (NULL);
    }

    adslMibHelper_filladslAturChanPerfDataTable
        (pAdslMib_adslAturChanPerfDataTable);
    *my_loop_context =
        (pADSL_MIB_ADSLATURCHANPERFDATATABLE)
        pAdslMib_adslAturChanPerfDataTable;
    *my_data_context =
        (pADSL_MIB_ADSLATURCHANPERFDATATABLE)
        pAdslMib_adslAturChanPerfDataTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAturChanPerfDataTable->
                       ifIndex,
                       sizeof(pAdslMib_adslAturChanPerfDataTable->
                              ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as adslAturChanPerfDataTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
adslAturChanPerfDataTable_get_next_data_point(void **my_loop_context,
                                              void **my_data_context,
                                              netsnmp_variable_list *
                                              put_index_data,
                                              netsnmp_iterator_info
                                              *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATURCHANPERFDATATABLE pAdslMib_adslAturChanPerfDataTable;

    ADSLMIB_DEBUG(("adslAturChanPerfDataTable_get_next_data_point"));

    pAdslMib_adslAturChanPerfDataTable =
        (pADSL_MIB_ADSLATURCHANPERFDATATABLE) * my_loop_context;
    pAdslMib_adslAturChanPerfDataTable =
        pAdslMib_adslAturChanPerfDataTable->next;

    if (pAdslMib_adslAturChanPerfDataTable == NULL)
        return (NULL);

    *my_loop_context =
        (pADSL_MIB_ADSLATURCHANPERFDATATABLE)
        pAdslMib_adslAturChanPerfDataTable;
    *my_data_context =
        (pADSL_MIB_ADSLATURCHANPERFDATATABLE)
        pAdslMib_adslAturChanPerfDataTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAturChanPerfDataTable->
                       ifIndex,
                       sizeof(pAdslMib_adslAturChanPerfDataTable->
                              ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the adslAturChanPerfDataTable table, if anything else needs to be done */
int
adslAturChanPerfDataTable_handler(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    pADSL_MIB_ADSLATURCHANPERFDATATABLE pAdslMib_adslAturChanPerfDataTable;

    ADSLMIB_DEBUG(("Entered adslAturChanPerfDataTable_handler"));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the adslAturChanPerfDataTable table in question 
         */
        pAdslMib_adslAturChanPerfDataTable =
            (pADSL_MIB_ADSLATURCHANPERFDATATABLE)
            netsnmp_extract_iterator_context(request);

        if (pAdslMib_adslAturChanPerfDataTable == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ADSLATURCHANRECEIVEDBLKS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanReceivedBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanReceivedBlks));
                break;

            case COLUMN_ADSLATURCHANTRANSMITTEDBLKS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanTransmittedBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanTransmittedBlks));
                break;

            case COLUMN_ADSLATURCHANCORRECTEDBLKS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanCorrectedBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanCorrectedBlks));
                break;

            case COLUMN_ADSLATURCHANUNCORRECTBLKS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanUncorrectBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanUncorrectBlks));
                break;

            case COLUMN_ADSLATURCHANPERFVALIDINTERVALS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfValidIntervals,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfValidIntervals));
                break;

            case COLUMN_ADSLATURCHANPERFINVALIDINTERVALS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfInvalidIntervals,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfInvalidIntervals));
                break;

            case COLUMN_ADSLATURCHANPERFCURR15MINTIMEELAPSED:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr15MinTimeElapsed,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr15MinTimeElapsed));
                break;

            case COLUMN_ADSLATURCHANPERFCURR15MINRECEIVEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr15MinReceivedBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr15MinReceivedBlks));
                break;

            case COLUMN_ADSLATURCHANPERFCURR15MINTRANSMITTEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr15MinTransmittedBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr15MinTransmittedBlks));
                break;

            case COLUMN_ADSLATURCHANPERFCURR15MINCORRECTEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr15MinCorrectedBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr15MinCorrectedBlks));
                break;

            case COLUMN_ADSLATURCHANPERFCURR15MINUNCORRECTBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr15MinUncorrectBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr15MinUncorrectBlks));
                break;

            case COLUMN_ADSLATURCHANPERFCURR1DAYTIMEELAPSED:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr1DayTimeElapsed,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr1DayTimeElapsed));
                break;

            case COLUMN_ADSLATURCHANPERFCURR1DAYRECEIVEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr1DayReceivedBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr1DayReceivedBlks));
                break;

            case COLUMN_ADSLATURCHANPERFCURR1DAYTRANSMITTEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr1DayTransmittedBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr1DayTransmittedBlks));
                break;

            case COLUMN_ADSLATURCHANPERFCURR1DAYCORRECTEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr1DayCorrectedBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr1DayCorrectedBlks));
                break;

            case COLUMN_ADSLATURCHANPERFCURR1DAYUNCORRECTBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr1DayUncorrectBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfCurr1DayUncorrectBlks));
                break;

            case COLUMN_ADSLATURCHANPERFPREV1DAYMONISECS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfPrev1DayMoniSecs,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfPrev1DayMoniSecs));
                break;

            case COLUMN_ADSLATURCHANPERFPREV1DAYRECEIVEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfPrev1DayReceivedBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfPrev1DayReceivedBlks));
                break;

            case COLUMN_ADSLATURCHANPERFPREV1DAYTRANSMITTEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfPrev1DayTransmittedBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfPrev1DayTransmittedBlks));
                break;

            case COLUMN_ADSLATURCHANPERFPREV1DAYCORRECTEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfPrev1DayCorrectedBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfPrev1DayCorrectedBlks));
                break;

            case COLUMN_ADSLATURCHANPERFPREV1DAYUNCORRECTBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfPrev1DayUncorrectBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanPerfDataTable->adslAturChanPerfPrev1DayUncorrectBlks));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in adslAturChanPerfDataTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in adslAturChanPerfDataTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ADSLATURCHANPERFDATATABLE */
#ifdef DO_ADSLATURINTERVALTABLE
/** free context of adslAturIntervalTable table */
void
adslAturIntervalTable_contextFree(void *context,
                                  netsnmp_iterator_info *dont_care)
{
    ADSLMIB_DEBUG(("\nadslAturIntervalTable_contextFree()\n"));

    free(((pADSL_MIB_ADSLATURINTERVALTABLE) context)->pTableBeginning);
}

/** Initialize the adslAturIntervalTable table by defining its contents and how it's structured */
void
initialize_table_adslAturIntervalTable(void)
{
    static oid      adslAturIntervalTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 9 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    ADSLMIB_DEBUG(("\ninitialize_table_adslAturIntervalTable()\n"));

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("adslAturIntervalTable",
                                            adslAturIntervalTable_handler,
                                            adslAturIntervalTable_oid,
                                            OID_LENGTH
                                            (adslAturIntervalTable_oid),
                                            HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     ASN_INTEGER,       /* index: adslAturIntervalNumber */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 6;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = (Netsnmp_First_Data_Point *)
        adslAturIntervalTable_get_first_data_point;
    iinfo->get_next_data_point = (Netsnmp_Next_Data_Point *)
        adslAturIntervalTable_get_next_data_point;
    iinfo->free_loop_context_at_end = adslAturIntervalTable_contextFree;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_adslAturIntervalTable",
                "Registering table adslAturIntervalTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** returns the first data point within the adslAturIntervalTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
adslAturIntervalTable_get_first_data_point(void **my_loop_context,
                                           void **my_data_context,
                                           netsnmp_variable_list *
                                           put_index_data,
                                           netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATURINTERVALTABLE pAdslMib_adslAturIntervalTable;
    int             ifCount;

    ifCount = adslMibHelper_getIfCount();
    pAdslMib_adslAturIntervalTable =
        calloc(ifCount*kAdslMibPerfIntervals,sizeof(ADSL_MIB_ADSLATURINTERVALTABLE));

    if (pAdslMib_adslAturIntervalTable == NULL) {
        printf("CANNOT ALLOCATE MEMORY: file %s, line %u \n", __FILE__,
               __LINE__);
        return (NULL);
    }

    adslMibHelper_filladslAturIntervalTable(pAdslMib_adslAturIntervalTable);
    *my_loop_context =
        (pADSL_MIB_ADSLATURINTERVALTABLE) pAdslMib_adslAturIntervalTable;
    *my_data_context =
        (pADSL_MIB_ADSLATURINTERVALTABLE) pAdslMib_adslAturIntervalTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAturIntervalTable->
                       ifIndex,
                       sizeof(pAdslMib_adslAturIntervalTable->ifIndex));
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAturIntervalTable->
                       adslAturIntervalNumber,
                       sizeof(pAdslMib_adslAturIntervalTable->adslAturIntervalNumber));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as adslAturIntervalTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
adslAturIntervalTable_get_next_data_point(void **my_loop_context,
                                          void **my_data_context,
                                          netsnmp_variable_list *
                                          put_index_data,
                                          netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATURINTERVALTABLE pAdslMib_adslAturIntervalTable;

    ADSLMIB_DEBUG(("adslAturIntervalTable_get_next_data_point"));

    pAdslMib_adslAturIntervalTable =
        (pADSL_MIB_ADSLATURINTERVALTABLE) * my_loop_context;
    pAdslMib_adslAturIntervalTable = pAdslMib_adslAturIntervalTable->next;

    if (pAdslMib_adslAturIntervalTable == NULL)
        return (NULL);

    *my_loop_context =
        (pADSL_MIB_ADSLATURINTERVALTABLE) pAdslMib_adslAturIntervalTable;
    *my_data_context =
        (pADSL_MIB_ADSLATURINTERVALTABLE) pAdslMib_adslAturIntervalTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAturIntervalTable->
                       ifIndex,
                       sizeof(pAdslMib_adslAturIntervalTable->ifIndex));
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAturIntervalTable->
                       adslAturIntervalNumber,
                       sizeof(pAdslMib_adslAturIntervalTable->adslAturIntervalNumber));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the adslAturIntervalTable table, if anything else needs to be done */
int
adslAturIntervalTable_handler(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info *reqinfo,
                              netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    pADSL_MIB_ADSLATURINTERVALTABLE pAdslMib_adslAturIntervalTable;

    ADSLMIB_DEBUG(("Entered adslAturIntervalTable_handler"));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the adslAturIntervalTable table in question 
         */
        pAdslMib_adslAturIntervalTable =
            (pADSL_MIB_ADSLATURINTERVALTABLE)
            netsnmp_extract_iterator_context(request);

        if (pAdslMib_adslAturIntervalTable == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ADSLATURINTERVALLOFS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturIntervalTable->adslAturIntervalLofs,
                                         sizeof
                                         (pAdslMib_adslAturIntervalTable->adslAturIntervalLofs));
                break;

            case COLUMN_ADSLATURINTERVALLOSS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturIntervalTable->adslAturIntervalLoss,
                                         sizeof
                                         (pAdslMib_adslAturIntervalTable->adslAturIntervalLoss));
                break;

            case COLUMN_ADSLATURINTERVALLPRS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturIntervalTable->adslAturIntervalLprs,
                                         sizeof
                                         (pAdslMib_adslAturIntervalTable->adslAturIntervalLprs));
                break;

            case COLUMN_ADSLATURINTERVALESS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturIntervalTable->adslAturIntervalESs,
                                         sizeof
                                         (pAdslMib_adslAturIntervalTable->adslAturIntervalESs));
                break;

            case COLUMN_ADSLATURINTERVALVALIDDATA:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAturIntervalTable->adslAturIntervalValidData,
                                         sizeof
                                         (pAdslMib_adslAturIntervalTable->adslAturIntervalValidData));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in adslAturIntervalTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in adslAturIntervalTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ADSLATURINTERVALTABLE */
#ifdef DO_ADSLATUCPHYSTABLE
/** free context of adslAtucPhysTable table */
void
adslAtucPhysTable_contextFree(void *context,
                              netsnmp_iterator_info *dont_care)
{
    ADSLMIB_DEBUG(("\nadslAtucPhysTable_contextFree()\n"));

    free(((pADSL_MIB_ADSLATUCPHYSTABLE) context)->pTableBeginning);
}

/** Initialize the adslAtucPhysTable table by defining its contents and how it's structured */
void
initialize_table_adslAtucPhysTable(void)
{
    static oid      adslAtucPhysTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 2 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    ADSLMIB_DEBUG(("\ninitialize_table_adslAtucPhysTable()\n"));

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("adslAtucPhysTable",
                                                     adslAtucPhysTable_handler,
                                                     adslAtucPhysTable_oid,
                                                     OID_LENGTH
                                                     (adslAtucPhysTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 8;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = (Netsnmp_First_Data_Point *)
        adslAtucPhysTable_get_first_data_point;
    iinfo->get_next_data_point = (Netsnmp_Next_Data_Point *)
        adslAtucPhysTable_get_next_data_point;
    iinfo->free_loop_context_at_end = adslAtucPhysTable_contextFree;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_adslAtucPhysTable",
                "Registering table adslAtucPhysTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** returns the first data point within the adslAtucPhysTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
adslAtucPhysTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATUCPHYSTABLE pAdslMib_adslAtucPhysTable;
    int             ifCount;

    ifCount = adslMibHelper_getIfCount();
    pAdslMib_adslAtucPhysTable =
        calloc(ifCount, sizeof(ADSL_MIB_ADSLATUCPHYSTABLE));

    if (pAdslMib_adslAtucPhysTable == NULL) {
        printf("CANNOT ALLOCATE MEMORY: file %s, line %u \n", __FILE__,
               __LINE__);
        return (NULL);
    }

    adslMibHelper_filladslAtucPhysTable(pAdslMib_adslAtucPhysTable);
    *my_loop_context =
        (pADSL_MIB_ADSLATUCPHYSTABLE) pAdslMib_adslAtucPhysTable;
    *my_data_context =
        (pADSL_MIB_ADSLATUCPHYSTABLE) pAdslMib_adslAtucPhysTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAtucPhysTable->ifIndex,
                       sizeof(pAdslMib_adslAtucPhysTable->ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as adslAtucPhysTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
adslAtucPhysTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATUCPHYSTABLE pAdslMib_adslAtucPhysTable;

    ADSLMIB_DEBUG(("adslAtucPhysTable_get_next_data_point"));

    pAdslMib_adslAtucPhysTable =
        (pADSL_MIB_ADSLATUCPHYSTABLE) * my_loop_context;
    pAdslMib_adslAtucPhysTable = pAdslMib_adslAtucPhysTable->next;

    if (pAdslMib_adslAtucPhysTable == NULL)
        return (NULL);

    *my_loop_context =
        (pADSL_MIB_ADSLATUCPHYSTABLE) pAdslMib_adslAtucPhysTable;
    *my_data_context =
        (pADSL_MIB_ADSLATUCPHYSTABLE) pAdslMib_adslAtucPhysTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAtucPhysTable->ifIndex,
                       sizeof(pAdslMib_adslAtucPhysTable->ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the adslAtucPhysTable table, if anything else needs to be done */
int
adslAtucPhysTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    pADSL_MIB_ADSLATUCPHYSTABLE pAdslMib_adslAtucPhysTable;

    ADSLMIB_DEBUG(("Entered adslAtucPhysTable_handler"));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the adslAtucPhysTable table in question 
         */
        pAdslMib_adslAtucPhysTable =
            (pADSL_MIB_ADSLATUCPHYSTABLE)
            netsnmp_extract_iterator_context(request);

        if (pAdslMib_adslAtucPhysTable == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ADSLATUCINVSERIALNUMBER:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) 
                                         pAdslMib_adslAtucPhysTable->adslAtucInvSerialNumber,
                                         strlen
                                         (pAdslMib_adslAtucPhysTable->adslAtucInvSerialNumber));
                break;

            case COLUMN_ADSLATUCINVVENDORID:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) 
                                         pAdslMib_adslAtucPhysTable->adslAtucInvVendorID,
                                         strlen
                                         (pAdslMib_adslAtucPhysTable->adslAtucInvVendorID));
                break;

            case COLUMN_ADSLATUCINVVERSIONNUMBER:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)
                                         pAdslMib_adslAtucPhysTable->adslAtucInvVersionNumber,
                                         strlen
                                         (pAdslMib_adslAtucPhysTable->adslAtucInvVersionNumber));
                break;

            case COLUMN_ADSLATUCCURRSNRMGN:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAtucPhysTable->adslAtucCurrSnrMgn,
                                         sizeof
                                         (pAdslMib_adslAtucPhysTable->adslAtucCurrSnrMgn));
                break;

            case COLUMN_ADSLATUCCURRATN:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucPhysTable->adslAtucCurrAtn,
                                         sizeof
                                         (pAdslMib_adslAtucPhysTable->adslAtucCurrAtn));
                break;

            case COLUMN_ADSLATUCCURRSTATUS:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *) &
                                         pAdslMib_adslAtucPhysTable->adslAtucCurrStatus,
                                         sizeof
                                         (pAdslMib_adslAtucPhysTable->adslAtucCurrStatus));
                break;

            case COLUMN_ADSLATUCCURROUTPUTPWR:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAtucPhysTable->adslAtucCurrOutputPwr,
                                         sizeof
                                         (pAdslMib_adslAtucPhysTable->adslAtucCurrOutputPwr));
                break;

            case COLUMN_ADSLATUCCURRATTAINABLERATE:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucPhysTable->adslAtucCurrAttainableRate,
                                         sizeof
                                         (pAdslMib_adslAtucPhysTable->adslAtucCurrAttainableRate));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in adslAtucPhysTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in adslAtucPhysTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ADSLATUCPHYSTABLE */
#ifdef DO_ADSLATUCCHANPERFDATATABLE
/** free context of adslAtucChanPerfDataTable table */
void
adslAtucChanPerfDataTable_contextFree(void *context,
                                      netsnmp_iterator_info *dont_care)
{
    ADSLMIB_DEBUG(("\nadslAtucChanPerfDataTable_contextFree()\n"));

    free(((pADSL_MIB_ADSLATUCCHANPERFDATATABLE) context)->pTableBeginning);
}

/** Initialize the adslAtucChanPerfDataTable table by defining its contents and how it's structured */
void
initialize_table_adslAtucChanPerfDataTable(void)
{
    static oid      adslAtucChanPerfDataTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 10 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    ADSLMIB_DEBUG(("\ninitialize_table_adslAtucChanPerfDataTable()\n"));

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("adslAtucChanPerfDataTable",
                                            adslAtucChanPerfDataTable_handler,
                                            adslAtucChanPerfDataTable_oid,
                                            OID_LENGTH
                                            (adslAtucChanPerfDataTable_oid),
                                            HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 21;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = (Netsnmp_First_Data_Point *)
        adslAtucChanPerfDataTable_get_first_data_point;
    iinfo->get_next_data_point = (Netsnmp_Next_Data_Point *)
        adslAtucChanPerfDataTable_get_next_data_point;
    iinfo->free_loop_context_at_end =
        adslAtucChanPerfDataTable_contextFree;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_adslAtucChanPerfDataTable",
                "Registering table adslAtucChanPerfDataTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** returns the first data point within the adslAtucChanPerfDataTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
adslAtucChanPerfDataTable_get_first_data_point(void **my_loop_context,
                                               void **my_data_context,
                                               netsnmp_variable_list *
                                               put_index_data,
                                               netsnmp_iterator_info
                                               *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATUCCHANPERFDATATABLE pAdslMib_adslAtucChanPerfDataTable;
    int             ifCount;

    ifCount = adslMibHelper_getIfCount();
    pAdslMib_adslAtucChanPerfDataTable =
        calloc(ifCount, sizeof(ADSL_MIB_ADSLATUCCHANPERFDATATABLE));

    if (pAdslMib_adslAtucChanPerfDataTable == NULL) {
        printf("CANNOT ALLOCATE MEMORY: file %s, line %u \n", __FILE__,
               __LINE__);
        return (NULL);
    }

    adslMibHelper_filladslAtucChanPerfDataTable
        (pAdslMib_adslAtucChanPerfDataTable);
    *my_loop_context =
        (pADSL_MIB_ADSLATUCCHANPERFDATATABLE)
        pAdslMib_adslAtucChanPerfDataTable;
    *my_data_context =
        (pADSL_MIB_ADSLATUCCHANPERFDATATABLE)
        pAdslMib_adslAtucChanPerfDataTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAtucChanPerfDataTable->
                       ifIndex,
                       sizeof(pAdslMib_adslAtucChanPerfDataTable->
                              ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as adslAtucChanPerfDataTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
adslAtucChanPerfDataTable_get_next_data_point(void **my_loop_context,
                                              void **my_data_context,
                                              netsnmp_variable_list *
                                              put_index_data,
                                              netsnmp_iterator_info
                                              *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATUCCHANPERFDATATABLE pAdslMib_adslAtucChanPerfDataTable;

    ADSLMIB_DEBUG(("adslAtucChanPerfDataTable_get_next_data_point"));

    pAdslMib_adslAtucChanPerfDataTable =
        (pADSL_MIB_ADSLATUCCHANPERFDATATABLE) * my_loop_context;
    pAdslMib_adslAtucChanPerfDataTable =
        pAdslMib_adslAtucChanPerfDataTable->next;

    if (pAdslMib_adslAtucChanPerfDataTable == NULL)
        return (NULL);

    *my_loop_context =
        (pADSL_MIB_ADSLATUCCHANPERFDATATABLE)
        pAdslMib_adslAtucChanPerfDataTable;
    *my_data_context =
        (pADSL_MIB_ADSLATUCCHANPERFDATATABLE)
        pAdslMib_adslAtucChanPerfDataTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAtucChanPerfDataTable->
                       ifIndex,
                       sizeof(pAdslMib_adslAtucChanPerfDataTable->
                              ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the adslAtucChanPerfDataTable table, if anything else needs to be done */
int
adslAtucChanPerfDataTable_handler(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    pADSL_MIB_ADSLATUCCHANPERFDATATABLE pAdslMib_adslAtucChanPerfDataTable;

    ADSLMIB_DEBUG(("Entered adslAtucChanPerfDataTable_handler"));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the adslAtucChanPerfDataTable table in question 
         */
        pAdslMib_adslAtucChanPerfDataTable =
            (pADSL_MIB_ADSLATUCCHANPERFDATATABLE)
            netsnmp_extract_iterator_context(request);

        if (pAdslMib_adslAtucChanPerfDataTable == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ADSLATUCCHANRECEIVEDBLKS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanReceivedBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanReceivedBlks));
                break;

            case COLUMN_ADSLATUCCHANTRANSMITTEDBLKS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanTransmittedBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanTransmittedBlks));
                break;

            case COLUMN_ADSLATUCCHANCORRECTEDBLKS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanCorrectedBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanCorrectedBlks));
                break;

            case COLUMN_ADSLATUCCHANUNCORRECTBLKS:
                snmp_set_var_typed_value(var, ASN_COUNTER,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanUncorrectBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanUncorrectBlks));
                break;

            case COLUMN_ADSLATUCCHANPERFVALIDINTERVALS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfValidIntervals,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfValidIntervals));
                break;

            case COLUMN_ADSLATUCCHANPERFINVALIDINTERVALS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfInvalidIntervals,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfInvalidIntervals));
                break;

            case COLUMN_ADSLATUCCHANPERFCURR15MINTIMEELAPSED:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr15MinTimeElapsed,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr15MinTimeElapsed));
                break;

            case COLUMN_ADSLATUCCHANPERFCURR15MINRECEIVEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr15MinReceivedBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr15MinReceivedBlks));
                break;

            case COLUMN_ADSLATUCCHANPERFCURR15MINTRANSMITTEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr15MinTransmittedBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr15MinTransmittedBlks));
                break;

            case COLUMN_ADSLATUCCHANPERFCURR15MINCORRECTEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr15MinCorrectedBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr15MinCorrectedBlks));
                break;

            case COLUMN_ADSLATUCCHANPERFCURR15MINUNCORRECTBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr15MinUncorrectBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr15MinUncorrectBlks));
                break;

            case COLUMN_ADSLATUCCHANPERFCURR1DAYTIMEELAPSED:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr1DayTimeElapsed,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr1DayTimeElapsed));
                break;

            case COLUMN_ADSLATUCCHANPERFCURR1DAYRECEIVEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr1DayReceivedBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr1DayReceivedBlks));
                break;

            case COLUMN_ADSLATUCCHANPERFCURR1DAYTRANSMITTEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr1DayTransmittedBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr1DayTransmittedBlks));
                break;

            case COLUMN_ADSLATUCCHANPERFCURR1DAYCORRECTEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr1DayCorrectedBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr1DayCorrectedBlks));
                break;

            case COLUMN_ADSLATUCCHANPERFCURR1DAYUNCORRECTBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr1DayUncorrectBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfCurr1DayUncorrectBlks));
                break;

            case COLUMN_ADSLATUCCHANPERFPREV1DAYMONISECS:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfPrev1DayMoniSecs,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfPrev1DayMoniSecs));
                break;

            case COLUMN_ADSLATUCCHANPERFPREV1DAYRECEIVEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfPrev1DayReceivedBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfPrev1DayReceivedBlks));
                break;

            case COLUMN_ADSLATUCCHANPERFPREV1DAYTRANSMITTEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfPrev1DayTransmittedBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfPrev1DayTransmittedBlks));
                break;

            case COLUMN_ADSLATUCCHANPERFPREV1DAYCORRECTEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfPrev1DayCorrectedBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfPrev1DayCorrectedBlks));
                break;

            case COLUMN_ADSLATUCCHANPERFPREV1DAYUNCORRECTBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfPrev1DayUncorrectBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanPerfDataTable->adslAtucChanPerfPrev1DayUncorrectBlks));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in adslAtucChanPerfDataTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in adslAtucChanPerfDataTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ADSLATUCCHANPERFDATATABLE */
#ifdef DO_ADSLATURCHANINTERVALTABLE
/** free context of adslAturChanIntervalTable table */
void
adslAturChanIntervalTable_contextFree(void *context,
                                      netsnmp_iterator_info *dont_care)
{
    ADSLMIB_DEBUG(("\nadslAturChanIntervalTable_contextFree()\n"));

    free(((pADSL_MIB_ADSLATURCHANINTERVALTABLE) context)->pTableBeginning);
}

/** Initialize the adslAturChanIntervalTable table by defining its contents and how it's structured */
void
initialize_table_adslAturChanIntervalTable(void)
{
    static oid      adslAturChanIntervalTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 13 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    ADSLMIB_DEBUG(("\ninitialize_table_adslAturChanIntervalTable()\n"));

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("adslAturChanIntervalTable",
                                            adslAturChanIntervalTable_handler,
                                            adslAturChanIntervalTable_oid,
                                            OID_LENGTH
                                            (adslAturChanIntervalTable_oid),
                                            HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     ASN_INTEGER,       /* index: adslAturChanIntervalNumber */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 6;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = (Netsnmp_First_Data_Point *)
        adslAturChanIntervalTable_get_first_data_point;
    iinfo->get_next_data_point = (Netsnmp_Next_Data_Point *)
        adslAturChanIntervalTable_get_next_data_point;
    iinfo->free_loop_context_at_end =
        adslAturChanIntervalTable_contextFree;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_adslAturChanIntervalTable",
                "Registering table adslAturChanIntervalTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** returns the first data point within the adslAturChanIntervalTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
adslAturChanIntervalTable_get_first_data_point(void **my_loop_context,
                                               void **my_data_context,
                                               netsnmp_variable_list *
                                               put_index_data,
                                               netsnmp_iterator_info
                                               *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATURCHANINTERVALTABLE pAdslMib_adslAturChanIntervalTable;
    int             ifCount;

    ifCount = adslMibHelper_getIfCount();
    pAdslMib_adslAturChanIntervalTable =
        calloc(ifCount*kAdslMibChanPerfIntervals, sizeof(ADSL_MIB_ADSLATURCHANINTERVALTABLE));

    if (pAdslMib_adslAturChanIntervalTable == NULL) {
        printf("CANNOT ALLOCATE MEMORY: file %s, line %u \n", __FILE__,
               __LINE__);
        return (NULL);
    }

    adslMibHelper_filladslAturChanIntervalTable
        (pAdslMib_adslAturChanIntervalTable);
    *my_loop_context =
        (pADSL_MIB_ADSLATURCHANINTERVALTABLE)
        pAdslMib_adslAturChanIntervalTable;
    *my_data_context =
        (pADSL_MIB_ADSLATURCHANINTERVALTABLE)
        pAdslMib_adslAturChanIntervalTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAturChanIntervalTable->
                       ifIndex,
                       sizeof(pAdslMib_adslAturChanIntervalTable->
                              ifIndex));
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAturChanIntervalTable->
                       adslAturChanIntervalNumber,
                       sizeof(pAdslMib_adslAturChanIntervalTable->
                              adslAturChanIntervalNumber));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as adslAturChanIntervalTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
adslAturChanIntervalTable_get_next_data_point(void **my_loop_context,
                                              void **my_data_context,
                                              netsnmp_variable_list *
                                              put_index_data,
                                              netsnmp_iterator_info
                                              *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATURCHANINTERVALTABLE pAdslMib_adslAturChanIntervalTable;

    ADSLMIB_DEBUG(("adslAturChanIntervalTable_get_next_data_point"));

    pAdslMib_adslAturChanIntervalTable =
        (pADSL_MIB_ADSLATURCHANINTERVALTABLE) * my_loop_context;
    pAdslMib_adslAturChanIntervalTable =
        pAdslMib_adslAturChanIntervalTable->next;

    if (pAdslMib_adslAturChanIntervalTable == NULL)
        return (NULL);

    *my_loop_context =
        (pADSL_MIB_ADSLATURCHANINTERVALTABLE)
        pAdslMib_adslAturChanIntervalTable;
    *my_data_context =
        (pADSL_MIB_ADSLATURCHANINTERVALTABLE)
        pAdslMib_adslAturChanIntervalTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAturChanIntervalTable->
                       ifIndex,
                       sizeof(pAdslMib_adslAturChanIntervalTable->
                              ifIndex));
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAturChanIntervalTable->
                       adslAturChanIntervalNumber,
                       sizeof(pAdslMib_adslAturChanIntervalTable->
                              adslAturChanIntervalNumber));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the adslAturChanIntervalTable table, if anything else needs to be done */
int
adslAturChanIntervalTable_handler(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    pADSL_MIB_ADSLATURCHANINTERVALTABLE pAdslMib_adslAturChanIntervalTable;

    ADSLMIB_DEBUG(("Entered adslAturChanIntervalTable_handler"));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the adslAturChanIntervalTable table in question 
         */
        pAdslMib_adslAturChanIntervalTable =
            (pADSL_MIB_ADSLATURCHANINTERVALTABLE)
            netsnmp_extract_iterator_context(request);

        if (pAdslMib_adslAturChanIntervalTable == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ADSLATURCHANINTERVALRECEIVEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanIntervalTable->adslAturChanIntervalReceivedBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanIntervalTable->adslAturChanIntervalReceivedBlks));
                break;

            case COLUMN_ADSLATURCHANINTERVALTRANSMITTEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanIntervalTable->adslAturChanIntervalTransmittedBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanIntervalTable->adslAturChanIntervalTransmittedBlks));
                break;

            case COLUMN_ADSLATURCHANINTERVALCORRECTEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanIntervalTable->adslAturChanIntervalCorrectedBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanIntervalTable->adslAturChanIntervalCorrectedBlks));
                break;

            case COLUMN_ADSLATURCHANINTERVALUNCORRECTBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAturChanIntervalTable->adslAturChanIntervalUncorrectBlks,
                                         sizeof
                                         (pAdslMib_adslAturChanIntervalTable->adslAturChanIntervalUncorrectBlks));
                break;

            case COLUMN_ADSLATURCHANINTERVALVALIDDATA:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAturChanIntervalTable->adslAturChanIntervalValidData,
                                         sizeof
                                         (pAdslMib_adslAturChanIntervalTable->adslAturChanIntervalValidData));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in adslAturChanIntervalTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in adslAturChanIntervalTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ADSLATURCHANINTERVALTABLE */
#ifdef DO_ADSLATUCCHANINTERVALTABLE
/** free context of adslAtucChanIntervalTable table */
void
adslAtucChanIntervalTable_contextFree(void *context,
                                      netsnmp_iterator_info *dont_care)
{
    ADSLMIB_DEBUG(("\nadslAtucChanIntervalTable_contextFree()\n"));

    free(((pADSL_MIB_ADSLATUCCHANINTERVALTABLE) context)->pTableBeginning);
}

/** Initialize the adslAtucChanIntervalTable table by defining its contents and how it's structured */
void
initialize_table_adslAtucChanIntervalTable(void)
{
    static oid      adslAtucChanIntervalTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 12 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    ADSLMIB_DEBUG(("\ninitialize_table_adslAtucChanIntervalTable()\n"));

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler =
        netsnmp_create_handler_registration("adslAtucChanIntervalTable",
                                            adslAtucChanIntervalTable_handler,
                                            adslAtucChanIntervalTable_oid,
                                            OID_LENGTH
                                            (adslAtucChanIntervalTable_oid),
                                            HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     ASN_INTEGER,       /* index: adslAtucChanIntervalNumber */
                                     0);

    table_info->min_column = 2;
    table_info->max_column = 6;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = (Netsnmp_First_Data_Point *)
        adslAtucChanIntervalTable_get_first_data_point;
    iinfo->get_next_data_point = (Netsnmp_Next_Data_Point *)
        adslAtucChanIntervalTable_get_next_data_point;
    iinfo->free_loop_context_at_end =
        adslAtucChanIntervalTable_contextFree;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_adslAtucChanIntervalTable",
                "Registering table adslAtucChanIntervalTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** returns the first data point within the adslAtucChanIntervalTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
adslAtucChanIntervalTable_get_first_data_point(void **my_loop_context,
                                               void **my_data_context,
                                               netsnmp_variable_list *
                                               put_index_data,
                                               netsnmp_iterator_info
                                               *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATUCCHANINTERVALTABLE pAdslMib_adslAtucChanIntervalTable;
    int             ifCount;

    ifCount = adslMibHelper_getIfCount();
    pAdslMib_adslAtucChanIntervalTable =
        calloc(ifCount, sizeof(ADSL_MIB_ADSLATUCCHANINTERVALTABLE));

    if (pAdslMib_adslAtucChanIntervalTable == NULL) {
        printf("CANNOT ALLOCATE MEMORY: file %s, line %u \n", __FILE__,
               __LINE__);
        return (NULL);
    }

    adslMibHelper_filladslAtucChanIntervalTable
        (pAdslMib_adslAtucChanIntervalTable);
    *my_loop_context =
        (pADSL_MIB_ADSLATUCCHANINTERVALTABLE)
        pAdslMib_adslAtucChanIntervalTable;
    *my_data_context =
        (pADSL_MIB_ADSLATUCCHANINTERVALTABLE)
        pAdslMib_adslAtucChanIntervalTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAtucChanIntervalTable->
                       ifIndex,
                       sizeof(pAdslMib_adslAtucChanIntervalTable->
                              ifIndex));
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAtucChanIntervalTable->
                       adslAtucChanIntervalNumber,
                       sizeof(pAdslMib_adslAtucChanIntervalTable->
                              adslAtucChanIntervalNumber));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as adslAtucChanIntervalTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
adslAtucChanIntervalTable_get_next_data_point(void **my_loop_context,
                                              void **my_data_context,
                                              netsnmp_variable_list *
                                              put_index_data,
                                              netsnmp_iterator_info
                                              *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATUCCHANINTERVALTABLE pAdslMib_adslAtucChanIntervalTable;

    ADSLMIB_DEBUG(("adslAtucChanIntervalTable_get_next_data_point"));

    pAdslMib_adslAtucChanIntervalTable =
        (pADSL_MIB_ADSLATUCCHANINTERVALTABLE) * my_loop_context;
    pAdslMib_adslAtucChanIntervalTable =
        pAdslMib_adslAtucChanIntervalTable->next;

    if (pAdslMib_adslAtucChanIntervalTable == NULL)
        return (NULL);

    *my_loop_context =
        (pADSL_MIB_ADSLATUCCHANINTERVALTABLE)
        pAdslMib_adslAtucChanIntervalTable;
    *my_data_context =
        (pADSL_MIB_ADSLATUCCHANINTERVALTABLE)
        pAdslMib_adslAtucChanIntervalTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAtucChanIntervalTable->
                       ifIndex,
                       sizeof(pAdslMib_adslAtucChanIntervalTable->
                              ifIndex));
    vptr = vptr->next_variable;
    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAtucChanIntervalTable->
                       adslAtucChanIntervalNumber,
                       sizeof(pAdslMib_adslAtucChanIntervalTable->
                              adslAtucChanIntervalNumber));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the adslAtucChanIntervalTable table, if anything else needs to be done */
int
adslAtucChanIntervalTable_handler(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    pADSL_MIB_ADSLATUCCHANINTERVALTABLE pAdslMib_adslAtucChanIntervalTable;

    ADSLMIB_DEBUG(("Entered adslAtucChanIntervalTable_handler"));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the adslAtucChanIntervalTable table in question 
         */
        pAdslMib_adslAtucChanIntervalTable =
            (pADSL_MIB_ADSLATUCCHANINTERVALTABLE)
            netsnmp_extract_iterator_context(request);

        if (pAdslMib_adslAtucChanIntervalTable == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ADSLATUCCHANINTERVALRECEIVEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanIntervalTable->adslAtucChanIntervalReceivedBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanIntervalTable->adslAtucChanIntervalReceivedBlks));
                break;

            case COLUMN_ADSLATUCCHANINTERVALTRANSMITTEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanIntervalTable->adslAtucChanIntervalTransmittedBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanIntervalTable->adslAtucChanIntervalTransmittedBlks));
                break;

            case COLUMN_ADSLATUCCHANINTERVALCORRECTEDBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanIntervalTable->adslAtucChanIntervalCorrectedBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanIntervalTable->adslAtucChanIntervalCorrectedBlks));
                break;

            case COLUMN_ADSLATUCCHANINTERVALUNCORRECTBLKS:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanIntervalTable->adslAtucChanIntervalUncorrectBlks,
                                         sizeof
                                         (pAdslMib_adslAtucChanIntervalTable->adslAtucChanIntervalUncorrectBlks));
                break;

            case COLUMN_ADSLATUCCHANINTERVALVALIDDATA:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanIntervalTable->adslAtucChanIntervalValidData,
                                         sizeof
                                         (pAdslMib_adslAtucChanIntervalTable->adslAtucChanIntervalValidData));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in adslAtucChanIntervalTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in adslAtucChanIntervalTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ADSLATUCCHANINTERVALTABLE */
#ifdef DO_ADSLLINETABLE
/** free context of adslLineTable table */
void
adslLineTable_contextFree(void *context, netsnmp_iterator_info *dont_care)
{
    ADSLMIB_DEBUG(("\nadslLineTable_contextFree()\n"));

    free(((pADSL_MIB_ADSLLINETABLE) context)->pTableBeginning);
}

/** Initialize the adslLineTable table by defining its contents and how it's structured */
void
initialize_table_adslLineTable(void)
{
    static oid      adslLineTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 1 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    ADSLMIB_DEBUG(("\ninitialize_table_adslLineTable()\n"));

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("adslLineTable",
                                                     adslLineTable_handler,
                                                     adslLineTable_oid,
                                                     OID_LENGTH
                                                     (adslLineTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 5;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = (Netsnmp_First_Data_Point *)
        adslLineTable_get_first_data_point;
    iinfo->get_next_data_point = (Netsnmp_Next_Data_Point *)
        adslLineTable_get_next_data_point;
    iinfo->free_loop_context_at_end = adslLineTable_contextFree;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_adslLineTable",
                "Registering table adslLineTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** returns the first data point within the adslLineTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
adslLineTable_get_first_data_point(void **my_loop_context,
                                   void **my_data_context,
                                   netsnmp_variable_list * put_index_data,
                                   netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLLINETABLE pAdslMib_adslLineTable;
    int             ifCount;

    ifCount = adslMibHelper_getIfCount();
    pAdslMib_adslLineTable =
        calloc(ifCount, sizeof(ADSL_MIB_ADSLLINETABLE));

    if (pAdslMib_adslLineTable == NULL) {
        printf("CANNOT ALLOCATE MEMORY: file %s, line %u \n", __FILE__,
               __LINE__);
        return (NULL);
    }

    adslMibHelper_filladslLineTable(pAdslMib_adslLineTable);
    *my_loop_context = (pADSL_MIB_ADSLLINETABLE) pAdslMib_adslLineTable;
    *my_data_context = (pADSL_MIB_ADSLLINETABLE) pAdslMib_adslLineTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *) & pAdslMib_adslLineTable->ifIndex,
                       sizeof(pAdslMib_adslLineTable->ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as adslLineTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
adslLineTable_get_next_data_point(void **my_loop_context,
                                  void **my_data_context,
                                  netsnmp_variable_list * put_index_data,
                                  netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLLINETABLE pAdslMib_adslLineTable;

    ADSLMIB_DEBUG(("adslLineTable_get_next_data_point"));

    pAdslMib_adslLineTable = (pADSL_MIB_ADSLLINETABLE) * my_loop_context;
    pAdslMib_adslLineTable = pAdslMib_adslLineTable->next;

    if (pAdslMib_adslLineTable == NULL)
        return (NULL);

    *my_loop_context = (pADSL_MIB_ADSLLINETABLE) pAdslMib_adslLineTable;
    *my_data_context = (pADSL_MIB_ADSLLINETABLE) pAdslMib_adslLineTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr, (u_char *) & pAdslMib_adslLineTable->ifIndex,
                       sizeof(pAdslMib_adslLineTable->ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the adslLineTable table, if anything else needs to be done */
int
adslLineTable_handler(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    pADSL_MIB_ADSLLINETABLE pAdslMib_adslLineTable;

    ADSLMIB_DEBUG(("Entered adslLineTable_handler"));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the adslLineTable table in question 
         */
        pAdslMib_adslLineTable =
            (pADSL_MIB_ADSLLINETABLE)
            netsnmp_extract_iterator_context(request);

        if (pAdslMib_adslLineTable == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ADSLLINECODING:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineTable->adslLineCoding,
                                         sizeof(pAdslMib_adslLineTable->adslLineCoding));
                break;

            case COLUMN_ADSLLINETYPE:
                snmp_set_var_typed_value(var, ASN_INTEGER,
                                         (u_char *) &
                                         pAdslMib_adslLineTable->adslLineType,
                                         sizeof(pAdslMib_adslLineTable->adslLineType));
                break;

            case COLUMN_ADSLLINESPECIFIC:
                snmp_set_var_typed_value(var, ASN_OBJECT_ID,
                                         (u_char *)
                                         pAdslMib_adslLineTable->adslLineSpecific,
                                         0);
                break;

            case COLUMN_ADSLLINECONFPROFILE:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)
                                         pAdslMib_adslLineTable->adslLineConfProfile,
                                         strlen(pAdslMib_adslLineTable->adslLineConfProfile));
                break;

            case COLUMN_ADSLLINEALARMCONFPROFILE:
                snmp_set_var_typed_value(var, ASN_OCTET_STR,
                                         (u_char *)
                                         pAdslMib_adslLineTable->adslLineAlarmConfProfile,
                                         strlen(pAdslMib_adslLineTable->adslLineAlarmConfProfile));
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in adslLineTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in adslLineTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ADSLLINETABLE */
#ifdef DO_ADSLATUCCHANTABLE
/** free context of adslAtucChanTable table */
void
adslAtucChanTable_contextFree(void *context,
                              netsnmp_iterator_info *dont_care)
{
    ADSLMIB_DEBUG(("\nadslAtucChanTable_contextFree()\n"));

    free(((pADSL_MIB_ADSLATUCCHANTABLE) context)->pTableBeginning);
}

/** Initialize the adslAtucChanTable table by defining its contents and how it's structured */
void
initialize_table_adslAtucChanTable(void)
{
    static oid      adslAtucChanTable_oid[] =
        { 1, 3, 6, 1, 2, 1, 10, 94, 1, 1, 4 };
    netsnmp_table_registration_info *table_info;
    netsnmp_handler_registration *my_handler;
    netsnmp_iterator_info *iinfo;

    ADSLMIB_DEBUG(("\ninitialize_table_adslAtucChanTable()\n"));

    /*
     * create the table structure itself 
     */
    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = netsnmp_create_handler_registration("adslAtucChanTable",
                                                     adslAtucChanTable_handler,
                                                     adslAtucChanTable_oid,
                                                     OID_LENGTH
                                                     (adslAtucChanTable_oid),
                                                     HANDLER_CAN_RONLY);

    if (!my_handler || !table_info || !iinfo)
        return;                 /* mallocs failed */

    /***************************************************
     * Setting up the table's definition
     */
    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER,   /* index: ifIndex */
                                     0);

    table_info->min_column = 1;
    table_info->max_column = 4;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = (Netsnmp_First_Data_Point *)
        adslAtucChanTable_get_first_data_point;
    iinfo->get_next_data_point = (Netsnmp_Next_Data_Point *)
        adslAtucChanTable_get_next_data_point;
    iinfo->free_loop_context_at_end = adslAtucChanTable_contextFree;

    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUGMSGTL(("initialize_table_adslAtucChanTable",
                "Registering table adslAtucChanTable as a table iterator\n"));
    netsnmp_register_table_iterator(my_handler, iinfo);
}

/** returns the first data point within the adslAtucChanTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
netsnmp_variable_list *
adslAtucChanTable_get_first_data_point(void **my_loop_context,
                                       void **my_data_context,
                                       netsnmp_variable_list *
                                       put_index_data,
                                       netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATUCCHANTABLE pAdslMib_adslAtucChanTable;
    int             ifCount;

    ifCount = adslMibHelper_getIfCount();
    pAdslMib_adslAtucChanTable =
        calloc(ifCount, sizeof(ADSL_MIB_ADSLATUCCHANTABLE));

    if (pAdslMib_adslAtucChanTable == NULL) {
        printf("CANNOT ALLOCATE MEMORY: file %s, line %u \n", __FILE__,
               __LINE__);
        return (NULL);
    }

    adslMibHelper_filladslAtucChanTable(pAdslMib_adslAtucChanTable);
    *my_loop_context =
        (pADSL_MIB_ADSLATUCCHANTABLE) pAdslMib_adslAtucChanTable;
    *my_data_context =
        (pADSL_MIB_ADSLATUCCHANTABLE) pAdslMib_adslAtucChanTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAtucChanTable->ifIndex,
                       sizeof(pAdslMib_adslAtucChanTable->ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** functionally the same as adslAtucChanTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

netsnmp_variable_list *
adslAtucChanTable_get_next_data_point(void **my_loop_context,
                                      void **my_data_context,
                                      netsnmp_variable_list *
                                      put_index_data,
                                      netsnmp_iterator_info *mydata)
{
    netsnmp_variable_list *vptr;
    pADSL_MIB_ADSLATUCCHANTABLE pAdslMib_adslAtucChanTable;

    ADSLMIB_DEBUG(("adslAtucChanTable_get_next_data_point"));

    pAdslMib_adslAtucChanTable =
        (pADSL_MIB_ADSLATUCCHANTABLE) * my_loop_context;
    pAdslMib_adslAtucChanTable = pAdslMib_adslAtucChanTable->next;

    if (pAdslMib_adslAtucChanTable == NULL)
        return (NULL);

    *my_loop_context =
        (pADSL_MIB_ADSLATUCCHANTABLE) pAdslMib_adslAtucChanTable;
    *my_data_context =
        (pADSL_MIB_ADSLATUCCHANTABLE) pAdslMib_adslAtucChanTable;

    vptr = put_index_data;

    snmp_set_var_value(vptr,
                       (u_char *) & pAdslMib_adslAtucChanTable->ifIndex,
                       sizeof(pAdslMib_adslAtucChanTable->ifIndex));
    vptr = vptr->next_variable;

    return put_index_data;
}

/** handles requests for the adslAtucChanTable table, if anything else needs to be done */
int
adslAtucChanTable_handler(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{

    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;
    netsnmp_variable_list *var;
    pADSL_MIB_ADSLATUCCHANTABLE pAdslMib_adslAtucChanTable;

    ADSLMIB_DEBUG(("Entered adslAtucChanTable_handler"));

    for (request = requests; request; request = request->next) {
        var = request->requestvb;
        if (request->processed != 0)
            continue;

        /*
         * perform anything here that you need to do before each
         * request is processed. 
         */

        /*
         * the following extracts the my_data_context pointer set in
         * the loop functions above.  You can then use the results to
         * help return data for the columns of the adslAtucChanTable table in question 
         */
        pAdslMib_adslAtucChanTable =
            (pADSL_MIB_ADSLATUCCHANTABLE)
            netsnmp_extract_iterator_context(request);

        if (pAdslMib_adslAtucChanTable == NULL) {
            if (reqinfo->mode == MODE_GET) {
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHINSTANCE);
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = netsnmp_extract_table_info(request);
        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list
         * have been set corresponding to the indexes of the
         * request 
         */
        if (table_info == NULL) {
            continue;
        }

        switch (reqinfo->mode) {
            /*
             * the table_iterator helper should change all GETNEXTs
             * into GETs for you automatically, so you don't have to
             * worry about the GETNEXT case.  Only GETs and SETs need
             * to be dealt with here 
             */
        case MODE_GET:
            switch (table_info->colnum) {
            case COLUMN_ADSLATUCCHANINTERLEAVEDELAY:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanTable->adslAtucChanInterleaveDelay,
                                         sizeof
                                         (pAdslMib_adslAtucChanTable->adslAtucChanInterleaveDelay));
                break;

            case COLUMN_ADSLATUCCHANCURRTXRATE:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanTable->adslAtucChanCurrTxRate,
                                         sizeof
                                         (pAdslMib_adslAtucChanTable->adslAtucChanCurrTxRate));
                break;

            case COLUMN_ADSLATUCCHANPREVTXRATE:
                snmp_set_var_typed_value(var, ASN_GAUGE,
                                         (u_char *) &
                                         pAdslMib_adslAtucChanTable->adslAtucChanPrevTxRate,
                                         sizeof
                                         (pAdslMib_adslAtucChanTable->adslAtucChanPrevTxRate));
                break;

            case COLUMN_ADSLATUCCHANCRCBLOCKLENGTH:
                snmp_set_var_typed_value(var, SNMP_NOSUCHOBJECT,
					 (u_char*)NULL,0);
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                snmp_log(LOG_ERR,
                         "problem encountered in adslAtucChanTable_handler: unknown column\n");
            }
            break;

        case MODE_SET_RESERVE1:
            /*
             * set handling... 
             */

        default:
            snmp_log(LOG_ERR,
                     "problem encountered in adslAtucChanTable_handler: unsupported mode\n");
        }
    }
    return SNMP_ERR_NOERROR;
}
#endif                          /* DO_ADSLATUCCHANTABLE */

/** Initializes the adslMIB module */
void
init_adsl_mib(void)
{
    /*
     * here we initialize all the tables we're planning on supporting 
     */
#ifdef DO_ADSLATURPHYSTABLE
    initialize_table_adslAturPhysTable();
#endif                          /* DO_ADSLATURPHYSTABLE */
#ifdef DO_ADSLLINECONFPROFILETABLE
    initialize_table_adslLineConfProfileTable();
#endif                          /* DO_ADSLLINECONFPROFILETABLE */
#ifdef DO_ADSLATURCHANTABLE
    initialize_table_adslAturChanTable();
#endif                          /* DO_ADSLATURCHANTABLE */
#ifdef DO_ADSLATUCPERFDATATABLE
    initialize_table_adslAtucPerfDataTable();
#endif                          /* DO_ADSLATUCPERFDATATABLE */
#ifdef DO_ADSLATUCINTERVALTABLE
    initialize_table_adslAtucIntervalTable();
#endif                          /* DO_ADSLATUCINTERVALTABLE */
#ifdef DO_ADSLATURPERFDATATABLE
    initialize_table_adslAturPerfDataTable();
#endif                          /* DO_ADSLATURPERFDATATABLE */
#ifdef DO_ADSLLINEALARMCONFPROFILETABLE
    initialize_table_adslLineAlarmConfProfileTable();
#endif                          /* DO_ADSLLINEALARMCONFPROFILETABLE */
#ifdef DO_ADSLATURCHANPERFDATATABLE
    initialize_table_adslAturChanPerfDataTable();
#endif                          /* DO_ADSLATURCHANPERFDATATABLE */
#ifdef DO_ADSLATURINTERVALTABLE
    initialize_table_adslAturIntervalTable();
#endif                          /* DO_ADSLATURINTERVALTABLE */
#ifdef DO_ADSLATUCPHYSTABLE
    initialize_table_adslAtucPhysTable();
#endif                          /* DO_ADSLATUCPHYSTABLE */
#ifdef DO_ADSLATUCCHANPERFDATATABLE
    initialize_table_adslAtucChanPerfDataTable();
#endif                          /* DO_ADSLATUCCHANPERFDATATABLE */
#ifdef DO_ADSLATURCHANINTERVALTABLE
    initialize_table_adslAturChanIntervalTable();
#endif                          /* DO_ADSLATURCHANINTERVALTABLE */
#ifdef DO_ADSLATUCCHANINTERVALTABLE
    initialize_table_adslAtucChanIntervalTable();
#endif                          /* DO_ADSLATUCCHANINTERVALTABLE */
#ifdef DO_ADSLLINETABLE
    initialize_table_adslLineTable();
#endif                          /* DO_ADSLLINETABLE */
#ifdef DO_ADSLATUCCHANTABLE
    initialize_table_adslAtucChanTable();
#endif                          /* DO_ADSLATUCCHANTABLE */
}

#else
void
init_adsl_mib(void)
{
  return;
}
#endif /* SNMP_ADSL_MIB */
